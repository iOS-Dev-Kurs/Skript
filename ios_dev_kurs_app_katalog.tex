\documentclass[parskip=half, final]{scrreprt}

\input{include/variables}
\input{include/style}
\input{include/code_listing}

\renewcommand{\doctype}{App Katalog}
\renewcommand{\shortdoctype}{App Katalog}

\begin{document}

\maketitle

\tableofcontents


\chapter{Einleitung}

\section{Über dieses Dokument}

Dieser App Katalog enthält Schritt-für-Schritt Anleitungen für die im Rahmen unseres Kurses erstellten Apps sowie die wöchentlich zu bearbeitenden Übungsaufgaben und wird im Verlauf des Semesters kapitelweise auf der Vorlesungswebseite \linkref{http://ios-dev-kurs.github.io/} zur Verfügung gestellt.

Er dient jedoch nur als Ergänzung zum parallel verfügbaren \strong{Skript}, auf das hier häufig verwiesen wird. Dort sind die Erläuterungen zu den verwendeten Technologien, Methoden und Begriffen zu finden.


\section{Workflow mit Git}\label{git_workflow}

Wir arbeiten in diesem Kurs mit der Versionskontroll-Software Git und der Software\-entwicklungs-Plattform GitHub \linkref{https://github.com/}. Mit diesen Werkzeugen kann ich euch Beispielprojekte und Aufgaben bereitstellen, die ihr bearbeiten und mir für Kommentare wieder zur Verfügung stellen könnt. Gleichzeitig lernt ihr dabei direkt den Umgang mit zwei der wichtigsten Werkzeuge in der modernen Softwareentwicklung.

Mit Git können wir Änderungen an einem Projekt, oder \emph{Repository}, in regelmäßigen Abständen in \emph{Commits} speichern. Dann können wir jederzeit zu vorherigen Commits zurückkehren und Änderungen vergleichen. Wer die Speicherpunkte bei Super Mario kennt weiß so etwas zu schätzen.

Außerdem ermöglicht uns Git mit anderen Entwicklern zusammenzuarbeiten. Dazu können wir das Repository auf einem Server wie GitHub bereitstellen. Speichert ein anderer Entwickler Commits in dem Repository, können wir dessen Änderungen mit einem \emph{Merge} mit unseren zusammenführen und dabei gegebenenfalls Konflikte beheben. So wird an Softwareprojekten weltweit zusammengearbeitet.

Da Git ein Kommandozeilenprogramm ist, bedarf es sicherlich einer Eingewöhnung. Wenn ihr noch wenig Erfahrung im Umgang mit der Komandozeile habt könnt ihr zum Einstieg die GitHub Desktop App \linkref{https://desktop.github.com} verwenden, mit der ihr Git über eine graphische Oberfläche bedienen könnt.

\subsection{Ein Repository forken, klonen und bearbeiten}\label{fork_and_clone}

Ich stelle Beispielprojekte und Aufgaben in Repositories wie diesem \linkref{https://github.com/ios-dev-kurs/helloworld} bereit. Verfahrt wie folgt, um es zum Bearbeiten herunterzuladen:

\begin{enumerate}

\item Erstellt einen GitHub Account \linkref{https://github.com/join}, wenn ihr noch keinen habt. Ladet euch die GitHub Desktop App herunter, wenn ihr eine graphische Oberfläche der Kommandozeile vorzieht.

\item Ihr habt nur Lese-Zugriff auf mein Repository. Ihr müsst daher erst einen \emph{Fork} \linkref{https://guides.github.com/activities/forking/} des Repositories erstellen und es damit auf euren Account kopieren. Klickt dazu einfach auf den \emph{Fork} Button auf der Repository-Seite.

\item Euren Fork könnt ihr nun nach Belieben bearbeiten. In diesem Beispiel ist das Fork-Repository unter der URL \url{https://github.com/dein-username/helloworld} verfügbar. Ihr könnt die Kommandozeile oder die GitHub Desktop App verwenden um das Repository herunterzuladen, oder zu \emph{klonen} \linkref{http://gitref.org/creating/\#clone}. Im Terminal lautet der Befehl dazu:
\begin{shcode}
git clone https://github.com/dein-username/helloworld
\end{shcode}

\item Nun könnt ihr an dem Projekt arbeiten. Mit folgendem Befehlt könnt ihr jederzeit überprüfen, welche Dateien sich geändert haben:
\begin{shcode}
git status
\end{shcode}

\item Speichert in regelmäßigen Abständen \emph{Commits} \linkref{http://gitref.org/basic/\#commit}. Jeder Arbeitsschritt sollte durch einen Commit repräsentiert werden. Achtet darauf, dass das Projekt bei jedem Commit funktionsfähig ist. In der Kommandozeile erstellt ihr einen Commit wie folgt:
\begin{shcode}
# Status überprüfen
git status
# Alle Änderungen dem nächsten Commit hinzufügen
git add --all
# Commit durchführen
git commit -m "Kurze Beschreibung der Änderungen"
\end{shcode}

\item Ihr könnt euer lokales Repository jederzeit mit eurem Repository auf GitHub abgleichen. Daher könnt ihr auch problemlos auf verschiedenen Rechnern an einem Projekt arbeiten. Führt einen \emph{Push} \linkref{http://gitref.org/remotes/\#push} oder \emph{Pull} \linkref{http://gitref.org/remotes/\#pull} in der Kommandozeile aus, oder klickt den \emph{Sync} Button in der GitHub Desktop App:
\begin{shcode}
# Fortschritt auf GitHub veröffentlichen
git push
# Änderungen von GitHub herunterladen
git pull
\end{shcode}

\end{enumerate}


\subsection{Eine Aufgabe per Pull-Request einreichen}\label{pull_request}

Habt ihr eine Aufgabe fertig und möchtet Sie einreichen, oder wenn ihr Hilfe benötigt, erstellt eine \emph{Pull-Request} \linkref{https://help.github.com/articles/creating-a-pull-request/}. Damit erhalte ich eine Benachrichtigung mit den Änderungen eures Forks im Vergleich zu meinem Original-Repository. Geht wie folgt vor:

\begin{enumerate}

\item Speichert eure Änderungen in einem Commit und veröffentlicht sie auf GitHub, wenn ihr es noch nicht getan habt.

\item Klickt auf der Repository-Seit den Button \emph{New Pull Request}, überprüft die Änderungen und klickt dann \emph{Create Pull Request}.

\item Gebt der Pull-Request einen Titel und beschreibt kurz die Änderungen. Erwähnt, wenn etwas nicht funktioniert, sodass ich euch helfen kann. Klickt schließlich auf \emph{Create Pull Request}.

\end{enumerate}




\begin{lecture} % Lecture 1


\chapter{Hello World}

Was ist schon ein Programmierkurs, der nicht mit einem klassischen \emph{Hello World} Programm beginnt? Wir werden jedoch noch einen Schritt weitergehen und diesen Gruß graphisch vom iOS Simulator und, soweit vorhanden, direkt von unseren eigenen iOS Geräten ausgeben lassen. Dabei stoßen wir auf unseren ersten \emph{Swift} Code und lernen die IDE \emph{Xcode} kennen. Wir arbeiten außerdem direkt mit der Versionskontroll-Software \emph{Git}, einem der Grundbausteine nahezu jedes Softwareprojekts.

\skriptref{Xcode, Programmieren in Swift, Versionskontrolle mit Git} sowie das Buch \emph{The Swift Programming Language} \linkref{https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/}


\section{"{}Hello World!"{} auf Simulator und Gerät}

\begin{enumerate}

\item Ich habe ein Beispielprojekt bereitgestellt, anhand dessen wir einen ersten Blick auf die Programmierung einer iOS App werfen. Das Ziel ist, das Projekt herunterzuladen, eine erste, einfache App zu schreiben und mir das Ergebnis für etwas \emph{konstruktive Kritik} zur Verfügung zu stellen. Dazu verwenden wir die Versionskontroll-Software \emph{Git} und die Softwareentwicklungs-Plattform \emph{GitHub}, die zu den Werkzeugen gehören, auf denen Softwareprojekte weltweit aufbauen und ohne die moderne Programmierung kaum noch denkbar ist.

Die erste Anweisung lautet:

\strong{\emph{Klont} einen \emph{Fork} des \emph{Repositories} \url{https://github.com/ios-dev-kurs/helloworld}.}

Wenn ihr noch mit keinem dieser Begriffe etwas anfangen könnt, seid beruhight: Wir werden noch so viel mit Git und GitHub arbeiten, dass ihr am Ende dieses Kurses Experten im Umgang damit seid. Befolgt zunächst einfach die Anweisungen in \autoref{fork_and_clone} \emph{Workflow mit Git} bis ihr das Beispielprojekt heruntergeladen habt.

\item Öffnet das Xcode-Projekt \filename{HelloWorld.xcodeproj} und macht euch mithilfe des Kapitels \emph{Xcode} im Skript mit der Benutzeroberfläche vertraut. In der Toolbar oben findet ihr auf der linken Seite die Steuerelemente des Compilers. Wählt das \emph{Target} \emph{HelloWorld} und ein Zielsystem, bspw. den \emph{iPhone 6s} Simulator, und klickt die \strong{\emph{Build \& Run}} Schaltfläche. Das Target wird nun kompiliert und generiert ein \emph{Product}, also unsere App, die im Simulator ausgeführt wird. Das Tastenkürzel für \emph{Build \& Run} in Xcode ist \keys{\cmd + R}.

\item Besonders spannend ist diese App natürlich noch nicht. Das ändern wir jetzt spektakulär, indem wir unseren \strong{ersten Swift Code} schreiben um eine Ausgabe hinzuzufügen. Wählt die Datei \filename{AppDelegate.swift} links im \emph{Project Navigator} aus.

\item Die Methode \swiftinline{application(_:didFinishLaunchingWithOptions:)} wird zu Beginn der Ausführung der App aufgerufen. Ersetzt den Kommentar dort mit einem Gruß zur Ausgabe in der Konsole:

\begin{swiftcode}
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
    print("Hello World!")
    return true
}
\end{swiftcode}

\item Wenn wir unsere App nun erneut mit \emph{Build \& Run} \keys{\cmd + R} kompilieren und ausführen, sehen wir den Text \str{Hello World!} in der Konsole. Dazu wird der zweigeteilte Debug-Bereich unten automatisch eingeblendet \abbref{img:helloworld_helloworld}. Ist der Konsolenbereich zunächst versteckt, kann er mit der Schaltfläche in der rechten unteren Ecke angezeigt werden. Außerdem wird links automatisch zum Debug Navigator gewechselt, wenn eine App ausgeführt wird, in dem CPU- und Speicherauslastung überwacht werden können und Fehler und Warnungen angezeigt werden, wenn welche auftreten.

\includegraphicsc[\screenshotwidth]{img/helloworld_helloworld.png}{img:helloworld_helloworld}{In der Konsole des Debug-Bereichs werden Ausgaben der laufenden App angezeigt}

\item Wenn ihr ein iOS Gerät dabei habt, verbindet es per USB-Kabel mit eurem Mac und wählt das Gerät in der Toolbar als Zielsystem aus. Mit einem \emph{Build \& Run} wird die App nun kompiliert, auf dem Gerät installiert und ausgeführt. In der Konsole erscheint wieder die Ausgabe \str{Hello World!}, diesmal direkt vom Gerät ausgegeben.

\end{enumerate}


\section{Graphisches "{}Hello World!"{}}

Natürlich wird ein Benutzer unserer App von den Ausgaben in der Konsole nichts mitbekommen. Diese dienen bei der Programmierung hauptsächlich dazu, Abläufe im Code nachzuvollziehen und Fehler zu finden. Unsere App ist also nur sinnvoll, wenn wir die Ausgaben auch auf dem Bildschirm darstellen können.

\skriptref{Xcode / Interface Builder}

\begin{enumerate}

\item Zur Gestaltung der Benutzeroberfläche oder \emph{User Interface (UI)} verwenden wir ein \emph{Storyboard}. Wählt im Project Navigator die Datei \emph{main.storyboard} aus.

\item Der Editor-Bereich zeigt nun den Interface Builder. In diesem Modus möchten wir häufig eine angepasste Konfiguration des Xcode-Fensters verwenden, es bietet sich also an, mit \keys{\cmd + T} einen neuen Tab zu öffnen. Blendet dann mit den Schaltflächen auf der rechten Seite der Toolbar den Navigator- und Debug-Bereich links und unten aus und den Inspektor rechts ein. Wählt dort außerdem zunächst den Standard-Editor, also die linke der drei Schaltflächen \abbref{img:helloworld_ib}.

\includegraphicsc[\screenshotwidth]{img/helloworld_ib.png}{img:helloworld_ib}{Für den Interface Builder verwenden wir eine angepasste Fensterkonfiguration mit dem Inspektor anstatt des Navigators}

\item Unser UI besteht bisher nur aus einer einzigen Ansicht, oder \emph{Scene}. Ein Pfeil kennzeichnet die Scene, die zum Start der App angezeigt wird. Im Inspektor rechts ist unten die Object Library zu finden. Wählt den entsprechenden Tab aus, wenn er noch nicht angezeigt wird \abbref{img:helloworld_ib}.

\item Durchsucht die Liste von Interfaceelementen nach einem Objekt der Klasse \swiftinline{UILabel}, indem ihr das Suchfeld unten verwendet, und zieht ein Label irgendwo auf die erste Scene. Doppelklickt auf das erstellte Label und tippt \str{Hello World!}.

\item Ein \emph{Build \& Run} mit einem iPhone-Zielsystem zeigt diesen Gruß nun statisch auf dem Bildschirm an.

\item Habt ihr das Label im Interface Builder ausgewählt, zeigt der Inspektor Informationen darüber an. Im \emph{Identity Inspector} könnt ihr euch vergewissern, dass das Objekt, was zur Laufzeit erzeugt wird und das Label darstellt, ein Objekt der Klasse \swiftinline{UILabel} ist. Im \emph{Attributes Inspector} stehen viele Optionen zur Auswahl, mit denen Eigenschaften wie Inhalt, Schrift und Farbe des Labels angepasst werden können.

\item Natürlich möchten wir unser UI zur Laufzeit mit Inhalt füllen und den Benutzer mit den Interfaceelementen interagieren lassen können. Zieht ein \swiftinline{UIButton}- und \swiftinline{UITextField}-Objekt auf die Scene und positioniert sie passend \abbref{img:helloworld_ui}. Mit dem Attributes Inspector könnt ihr dem Button nun den Titel \str{Say Hello!} geben und für das Text Field einen Placeholder \str{Name} einstellen.

\includegraphicsc[.6\textwidth]{img/helloworld_ui.png}{img:helloworld_ui}{Mit einem Text Field, einem Button und einem Label erstellen wir ein simples UI}

\item Damit sich das Layout an jede Bildschirmgröße automatisch anpasst, verwenden wir nun \emph{Auto Layout}. Die Schaltflächen dazu findet ihr in der unteren rechten Ecke des Interface Builder Editors. Markiert mit gedrückter \keys{\cmd}-Taste die drei Interfaceelemente und klickt auf das Linke der Symbole mit dem Titel \emph{Stack}, sodass die Elemente in eine \emph{Stack View} eingebettet werden. Dieses praktische Objekt positioniert die enthaltenen Elemente automatisch relativ zueinander. Wählt die Stack View aus und konfiguriert im Attributes Inspector \emph{Axis Vertical}, \emph{Alignment Fill}, \emph{Distribution Fill} und \emph{Spacing 8}. Zusätzlich müssen wir Regeln aufstellen, wie die Stack View auf dem Bildschirm positioniert werden soll. Dazu erstellen wir \emph{Constraints} mit den beiden mittleren der Auto Layout Schaltflächen. Befestigt die Stack View links und rechts am Rand und zentriert sie vertikal.

\item Zur Laufzeit der App wird für jedes im Storyboard konfigurierte Interfaceelement ein Objekt der entsprechenden Klasse erstellt und dessen Attribute gesetzt. Um nun im Code auf die erstellten Objekte zugreifen und auf Benutzereingaben reagieren zu können, verwenden wir \emph{IBOutlets} und \emph{IBActions}.
	
Blendet den Inspektor aus und wählt stattdessen den Assistant-Editor (mittlere Schaltfläche) in der Toolbar. Stellt den Modus in der Jump bar auf \emph{Automatic}. Im Assistant wird automatisch die Implementierung des übergeordneten View Controllers eingeblendet \abbref{img:helloworld_assistant}.

\includegraphicsc[\screenshotwidth]{img/helloworld_assistant.png}{img:helloworld_assistant}{Mithilfe des Assistants können Interface-Builder und Code nebeneinander angezeigt werden.}

\item \emph{View Controller} sind Objekte einer Subklasse von \swiftinline{UIViewController}, die jeweils einen Teil der App steuern. Diese sind zentrale Bestandteile einer App, mit denen wir uns noch detailliert beschäftigen werden. Ein erster View Controller zur Steuerung dieser ersten Ansicht ist im Projekt bereits enthalten.

Fügt dieser Klasse \swiftinline{ViewController: UIViewController} Attribute für das \swiftinline{UILabel} und das \swiftinline{UITextField} hinzu und kennzeichnet diese mit \swiftinline{@IBOutlet}. Implementiert außerdem eine mit \swiftinline{IBAction} gekennzeichnete Methode, die aufgerufen werden soll, wenn der Benutzer den \swiftinline{UIButton} betätigt:

\begin{swiftcode}
import UIKit

class ViewController: UIViewController {

    @IBOutlet var nameTextfield: UITextField!
    @IBOutlet var greetingLabel: UILabel!

    @IBAction func greetingButtonPressed(sender: UIButton) {
        print("Hello World!")
    }
    
}
@end
\end{swiftcode}

\item Nun zieht mit gedrückter \keys{\ctrl}-Taste eine Linie von dem Textfeld und dem Label im Interface Builder auf das jeweilige Attribut im Code. Die Codezeile wird dabei blau hinterlegt. Zieht außerdem genauso eine Line von dem Button auf die zuvor definierte Methode. Im Connection Inspector könnt ihr die IBOutlets und IBActions eines ausgewählten Objekts betrachten und wieder entfernen. Dieser Prozess ist im Skript noch detaillierter beschrieben.

\item Versucht nun einen \emph{Build \& Run}. Betätigt ihr den Button, wird die Methode ausgeführt und der Gruß \str{Hello World!} in der Konsole ausgegeben!

\item Um die App nun alltagstauglich zu gestalten, muss dieser Gruß natürlich personalisiert und auf dem Bildschirm angezeigt werden. Dazu verwenden wir das Attribut \swiftinline{text} der Klassen \swiftinline{UITextField} und \swiftinline{UILabel} und zeigen einen personalisierten Gruß an, wenn im Text Field ein Name geschrieben steht:

\begin{swiftcode}
@IBAction func greetingButtonPressed(sender: UIButton) {
    if let name = nameTextfield.text where !name.isEmpty {
        greetingLabel.text = "Hello \(name)!"
    } else {
        greetingLabel.text = "Hello World!"
    }
}
\end{swiftcode}

Nach einem \emph{Build \& Run} erhalten wir unser erstes interaktives Interface, in dem ihr im Textfeld einen Namen eintippen könnt und persönlich begrüßt werdet \abbref{img:helloworld_final}!

\includegraphicsc[\iphonewidth]{img/helloworld_final.png}{img:helloworld_final}{Drücken wir auf den Button, werden wir persönlich begrüßt. Sehr praktisch!}

\item Die App ist fertig! Eure Eltern werden stolz auf euch sein. Gebt mir nun die Gelegenheit, eure Arbeit zu kommentieren. Wir verwendet dazu wieder Git, um die Änderungen, an denen ihr gerade gearbeitet habt, zu speichern, hochzuladen und mir zur Verfügung zu stellen. Befolgt dazu die weiteren Anweisungen in \autoref{pull_request}, bis ihr mir eine \emph{Pull-Request} geschickt habt.

\end{enumerate}

\begin{exc}

\begin{excitem}{simpleui}{Simple UI}{2}

Erstellt einen Fork des Repositories \url{https://github.com/ios-dev-kurs/simpleui} und schreibt eine App mit einigen Interfaceelementen, die etwas sinnvolles tut. Stellt mir das Ergebnis anschließend als Pull-Request zur Verfügung.

Implementiert eines der folgenden Beispiele oder eine eigene Idee. Ich freue mich auf kreative Apps!

\begin{description}
\item[Counter] Auf dem Bildschirm ist ein Label zu sehen, das den Wert eines Attributs \swiftinline{var count: Int} anzeigt, wenn eine Methode \swiftinline{updateLabel} aufgerufen wird. Buttons mit den Titeln \str{+1}, \str{-1} und \str{Reset} ändern den Wert dieses Attributs entsprechend und rufen die \swiftinline{updateLabel}-Methode auf.
\item[BMI] Nach Eingabe von Gewicht $m$ und Größe $l$ wird der Body-Mass-Index\linkref{http://de.wikipedia.org/wiki/Body-Mass-Index} $BMI=m/l^2$ berechnet und angezeigt.
\item[RGB] In drei Textfelder kann jeweils ein Wert zwischen 0 und 255 für die Rot-, Grün- oder Blau-Komponenten eingegeben werden. Ein Button setzt die Hintergrundfarbe \swiftinline{self.view.backgroundColor} entsprechend und ein weiterer Button generiert eine zufällige Hintergrundfarbe. Ihr könnt noch einen \swiftinline{UISwitch} hinzufügen, der einen Timer ein- und ausschaltet und damit die Hintergrundfarbe bei jedem Timerintervall zufällig wechselt (s. Hinweis).
\end{description}

\begin{exchinweise}
\item In der nächsten Vorlesung lernen wir die Objektorientierte Programmierung in Swift systematisch. Orientiert euch für diese Aufgabe an der \emph{HelloWorld} App und versucht die Funktionalität mit den folgenden Hinweisen zu implementieren. Wenn ihr nicht weiter kommt, schickt mir eine Pull-Request mit einem Kommentar und ich helfe euch.
\item Das Attribut \swiftinline{text} von \swiftinline{UILabel} und \swiftinline{UITextField} gibt eine \emph{optionale} Zeichenkette \swiftinline{String?} zurück. Ihr werdet euch mit solchen \emph{Optionals} solange herumärgern, bis ihr sie zu schätzen lernt. Verwendet die \emph{Optional Binding} Syntax um das Optional zu entpacken:
\begin{swiftcode}
if let name = nameTextfield.text {
    // name existiert und kann verwendet werden
} else {
    // nameTextfield.text hat keinen Wert
}
\end{swiftcode}
\item Einen \swiftinline{String} könnt ihr schnell in eine ganze Zahl \swiftinline{Int} oder eine Dezimalzahl \swiftinline{Double} umwandeln. Da dies fehlschlagen kann, gibt auch diese Operation einen Optional \swiftinline{Int?} bzw. \swiftinline{Double?} zurück, den wir entpacken müssen:
	\begin{swiftcode}
    // Sei text ein String
    if let number = Double(text) {
        // text konnte in eine Zahl number umgewandelt werden
    }
	\end{swiftcode}
\item Definiert ein Attribut wie \swiftinline{var count: Int} mit einem Startwert:
\begin{swiftcode}
class ViewController: UIViewController {

    var count: Int = 0
    
    // ...
}
\end{swiftcode}
\item Natürlich gibt es die grundlegenden Rechenoperationen \swiftinline{+-*/} in Swift. Diese Operationen können mit der Zuweisung zu einer Variablen verbunden werden, um bspw. eine Variable \swiftinline{count} um \swiftinline{1} zu erhöhen:
\begin{swiftcode}
count += 1
\end{swiftcode}
\item Eine Farbe wird durch die Klasse \swiftinline{UIColor} repräsentiert. Der \emph{Initializer} \swiftinline{UIColor(red:green:blue:alpha:)} akzeptiert jeweils Werte zwischen 0 und 1:
\begin{swiftcode}
let color = UIColor(red: 1, green: 0, blue: 0, alpha: 1) // rot
\end{swiftcode}
\item Die Funktion \swiftinline{arc4random_uniform(n)} gibt eine Pseudozufallszahl $x$ mit $0<=x<n$ aus.
\item Wenn ein \swiftinline{UISwitch} betätigt wird, kann das Event genauso mit einer IBAction verbunden werden wie das eines \swiftinline{UIButton}. Mit einem Attribut \swiftinline{var randomTimer: NSTimer?} können wir dann die Methode für das zufällige Wechseln der Hintergrundfarbe implementieren:
\begin{swiftcode}
var randomTimer: NSTimer?

@IBAction func switchValueChanged(sender: UISwitch) {
    if sender.on {
        randomTimer = NSTimer.scheduledTimerWithTimeInterval(0.15, target: self, selector: "randomButtonPressed:", userInfo: nil, repeats: true)
    } else {
        randomTimer?.invalidate()
        randomTimer = nil
    }
}
\end{swiftcode}
	Somit wird periodisch die Methode \swiftinline{randomButtonPressed(_:)} aufgerufen, die natürlich implementiert sein muss.

\end{exchinweise}

\end{excitem}

\end{exc}


\end{lecture}



\begin{lecture} % Lecture 2


\chapter{A Swift Tour}

Für unsere ersten Apps hat eine gute Portion Intuition für ein wenig Swift Code ausgereicht. Bevor wir tiefer in die App-Programmierung einsteigen beschäftigen wir uns einmal genauer mit der Programmierung in Swift.

Apple bietet mit dem Buch \emph{The Swift Programming Language} eine hervorragende Dokumentation und ein einführendes Kapitel mit den Namen \emph{A Swift Tour}. Das Buch findet ihr sowohl online \linkref{https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/} als auch im iBooks Store \linkref{https://itunes.apple.com/de/book/swift-programming-language/id881256329?mt=11} immer in aktueller Version. Auch das letzte Kapitel \emph{Language Reference} ist sehr spannend wenn ihr euch für den detaillierten Aufbau der Sprache und deren Grammatik interessiert.

Löst die Übungsaufgaben mit eurem Wissen aus der Vorlesung und den zugehörigen Materialien auf der Vorlesungwebseite. Zieht zuerst das Buch \emph{The Swift Programming Language} zu Rate wenn ihr nicht weiterkommt. Schickt mir bei weiteren Fragen eine Pull-Request oder einen Xcode Playground per Email.

\strong{Xcode Playgrounds} eignen sich hervorragend um Swift Code auszuprobieren und um Code zu schreiben der die Infrastruktur einer App nicht erfordert, wie bspw. die Übungsaufgaben \emph{Fibonacci}, \emph{Primzahlen} und \emph{Poker}. Erstellt einen Playground mit \menu{File > New > Playground...} oder \keys{\cmd + \shift + \Alt + N}.

Die Übungsaufgaben \emph{Fibonacci} und \emph{Primzahlen} sind optional und an Kursteilnehmer gerichtet, die noch wenig oder keine Programmierkenntnisse mitbringen. Auch erfahrene Programmierer können aber anhand dieser Aufgaben die Swift Syntax kennenlernen und versuchen die Aufgaben so \emph{swifty} wie möglich zu lösen.

\begin{exc}

\begin{excitem*}{fibonacci}{Fibonacci}{1}

Schreibt in einem Xcode Playground einen Algorithmus der alle Folgenglieder $F_n < 1000$ der Fibonaccifolge
\begin{equation}
F_n = F_{n-1} + F_{n-2}
\end{equation}
\begin{equation}
F_1=1, F_2=2
\end{equation}
in der Konsole ausgibt.

\exchinweis{Versucht's mit einer \swiftinline{while}-Schleife und zwei Variablen für die letzten beiden Folgenglieder, die außerhalb der Schleife definiert wurden. Wer die Aufgabe richtig \emph{swifty} lösen will kann stattdessen ein \swiftinline{struct: FibonacciSequence} schreiben welches das \swiftinline{SequenceType} Protokoll erfüllt.}

\end{excitem*}


\begin{excitem*}{primenumbers}{Primzahlen}{1}

\begin{enumerate}

\item Schreibt eine Funktion \swiftinline{func isPrimeNumber(n: Int) -> Bool} die eine Zahl annimmt und \swiftinline{true} zurückgibt, wenn diese eine Primzahl ist, andernfalls \swiftinline{false}.

\exchinweis{Iteriert in einer \swiftinline{for}-Schleife durch alle Zahlen von 2 bis n: \swiftinline{for i in 2..<n}. Überspringt den Schleifenschritt mit \swiftinline{continue} wenn \swiftinline{i} gleich \swiftinline{n} ist. Prüft sonst mit dem Modulo-Operator \swiftinline{|\%|} den Rest der Division \swiftinline{n |\%| i} der beiden Zahlen. Ist dieser \swiftinline{0} so ist \swiftinline{n} durch \swiftinline{i} teilbar und ihr könnt \swiftinline{false} zurückgeben: \swiftinline{return false}. Gebt sonst nach dem Durchlauf der Schleife \swiftinline{true} zurück.}

\item Schreibt dann eine Funktion \swiftinline{func primeNumbersUpTo(maxNumber: Int) -> [Int]} die alle Primzahlen bis \swiftinline{maxNumber} als Liste \swiftinline{[Int]} (kurz für \swiftinline{Array<Int>}) zurückgibt.

\exchinweis{Erstellt zuerst eine leere Liste von \swiftinline{Int}s: \swiftinline{var primeNumbers: [Int] = []}. Iteriert dann in einer \swiftinline{for}-Schleife durch die Zahlen \swiftinline{1...maxNumber} und fügt die Zahl der Liste mit \swiftinline{primeNumbers.append(n)} hinzu wenn sie \swiftinline{isPrimeNumber(n)} erfüllt. Gebt die Liste mit \swiftinline{return primeNumbers} nach Schleifendurchlauf zurück. Richtig \emph{swifty} könnt ihr die Aufgabe auch in einer Zeile lösen indem ihr die Methode \swiftinline{filter} von \swiftinline{SequenceType} verwendet.}

\end{enumerate}

\end{excitem*}


\begin{excitem}{chatter}{Chatter}{2}

In dieser Aufgabe schreiben wir zusammen an einer App!

Forkt das Repository \url{https://github.com/ios-dev-kurs/chatter} und erstellt eine Pull Request um eure Lösung einzureichen oder Fragen zu stellen.

\begin{enumerate}[label=\roman*.]

\item Die \emph{Chatter} App ist in der \filename{README.md} Datei beschrieben. Ihr könnt euch die Projektdateien anschauen und die App im Simulator oder auf euren Geräten ausführen und ausprobieren. Wenn euch interessiert, wie die App aufgebaut ist, lest die \filename{README.md} und die Kommentare im Code.

\item Ihr habt nun sicherlich erkannt worum es in der App geht: Instanzen verschiedener Subklassen von \swiftinline{Chatter} chatten miteinander. Dabei überschreiben die Subklassen jeweils nur die Implementierung weniger Methoden, die in der \swiftinline{Chatter} Klasse dokumentiert sind.

Eure Aufgabe ist es nun, eine eigene Subklasse zu schreiben und damit euren Beitrag zu dieser App zu leisten! Ihr könnt einen bekannten Charakter darstellen oder einen Neuen erschaffen. Ich übernehme eure Pull-Request dann in das Original-Repository, sodass euer Charakter mit denen aller anderen Kursteilnehmer chatten kann.

Erstellt dazu mit \keys{\cmd + N} eine neue \filename{.swift}-Datei mit dem Namen eures Charakters und platziert sie im Xcode Project Navigator unter \menu{chatter > Model > Chatters}. Orientiert euch an \swiftinline{Yoda.swift} um eure neue Subklasse von \swiftinline{Chatter} zu implementieren.

\item Überschreib die relevanten Methoden in eurer Subklasse wie in der \filename{README.md} Datei beschrieben. Hier könnt ihr einfach zufällige Chatnachrichten generieren, oder auch komplexere Mechaniken einbauen, sodass eine etwas natürlichere Konversation zustande kommt.

In eurer eigenen Subklasse könnt ihr dabei beliebig Code schreiben und bspw. Attribute einführen, um den Zustand eures Charakters darzustellen, wenn ihr möchtet. Er oder sie (oder es?) könnte bspw. mit jeder Nachricht wütender werden oder dergleichen.

\item Sichert eure Änderungen regelmäßig in Commits, wenn der Code fehlerfrei kompiliert. Achtet darauf nur Änderungen eurer Subklasse und nur wenn nötig Änderungen in anderen Dateien zu committen. Die \filename{project.pbxproj} Datei enthält Informationen zu den Projektdateien - da ihr neue Dateien hinzugefügt habt, gehört diese zum Commit dazu.

\item Mit eurem Fork des Repositories auf GitHub könnt ihr eure Änderungen jederzeit abgleichen. Bei der Gelegenheit bietet es sich an auch die neuesten Änderungen aus dem Original-Repository herunterzuladen, sodass ihr die neuen Charaktere der anderen Kursteilnehmer erhaltet:

\begin{shcode}
git pull https://github.com/ios-dev-kurs/chatter.git master
\end{shcode}

Die \shinline{pull} Operation versucht, die heruntergeladenen Änderungen mit den lokalen Änderungen zusammenzuführen. Das klappt nicht immer ohne Konflikte. Da jeder von euch dem Projekt eine Datei hinzufügt ändert sich jeweils die \filename{project.pbxproj} Datei. Treten Konflikte auf, müsst die die Datei in einem Texteditor öffnen und nach den Konfliktmarkierungen suchen:

\begin{shcode}
<<<<<<< HEAD:
# lokaler Code vor dem Merge
=======
# durch den Merge veränderter Code
>>>>>>>
\end{shcode}

Behebt den Konflikt indem ihr die Konfliktmarkierungen löscht und den Code dazwischen gegebenenfalls anpasst. Dann könnt ihr den Merge committen:

\begin{shcode}
git add --all
git commit
\end{shcode}

Euer Repository enthält dann sowohl den aktuellen Stand des Original-Repositories, als auch eure Änderungen.

\item Wenn ihr mit eurer neuen \swiftinline{Chatter} Subklasse zufrieden seid schickt mir eine Pull-Request. So werden eure Änderungen in das Original-Repository integriert und tauchen auch bei den anderen Teilnehmern auf, wenn diese das nächste mal einen \shinline{git pull} durchführen.

Ich bin gespannt auf eure Implementierungen!

\end{enumerate}

\end{excitem}


\begin{excitem}{emails}{Poker}{3}

In dieser Aufgabe berechnen wir die Wahrscheinlichkeit für einen \emph{Flush} beim Poker.

Forkt das Repository \url{https://github.com/ios-dev-kurs/poker} und erstellt eine Pull Request um eure Lösung einzureichen oder Fragen zu stellen.

\begin{enumerate}[label=\roman*.]

\item Zuerst modellieren wir die Spielkarten. Eine Karte \swiftinline{Card} hat immer eine \emph{Farbe} \swiftinline{Suit} (Karo, Herz, Pik oder Kreuz) und einen \emph{Rang} \swiftinline{Rank} (2 bis 10, Bube, Dame, König oder Ass).

Wir modellieren \swiftinline{Card} als Struct, und \swiftinline{Suit} und \swiftinline{Rank} als Enums. Warum verwenden wir keine Klasse für \swiftinline{Card}? Warum eignet sich ein Enum so hervorragend für \swiftinline{Suit} und \swiftinline{Rank}? Beantwortet diese Fragen kurz stichwortartig in einem Kommentar im Playground.

\item Schreibt zwei Enums \swiftinline{enum Suit: Int} und \swiftinline{enum Rank: Int} mit ihren jeweiligen Fällen (\swiftinline{case diamonds} usw.). Bei den Rängen \emph{2} bis \emph{10} schreibt ihr am besten die Zahl aus (\swiftinline{case two} usw.).

Implementiert jeweils eine \emph{Computed Property} \swiftinline{var description: String} in der ihr mithilfe einer \swiftinline{switch}-Abfrage für jeden Fall ein Symbol zurückgebt. \strong{Tipp:} Für Karo, Herz, Pik und Kreuz gibt es Unicode-Symbole\linkref{http://en.wikipedia.org/wiki/Playing_cards_in_Unicode}! Außerdem verlangt das Protokoll \swiftinline{CustomStringConvertible} nur das Attribut \swiftinline{description}, schreibt also z.B. \swiftinline{enum Suit: Int, CustomStringConvertible} damit das Symbol in \swiftinline{print}s verwendet wird.
	
Schreibt dann einen \swiftinline{struct Card} mit zwei Attributen \swiftinline{let suit: Suit} und \swiftinline{let rank: Rank}, sowie einer \emph{Computed Property} \swiftinline{var description: String}, die einen aus Farbe und Rang zusammengesetzten String zurückgibt. Lasst auch \swiftinline{Card} das \swiftinline{CustomStringConvertible} Protokoll erfüllen.
		
\item Nun können wir eine Poker Hand modellieren. Schreibt den \swiftinline{struct PokerHand} mit einem Attribut \swiftinline{let cards: [Card]} und einer \emph{Computed Property} \swiftinline{var description: String}, die die \swiftinline{description} der Karten kombiniert.

Um einfach zufällige Poker Hände generieren zu können, implementiert einen Initializer \swiftinline{init()}, der eine Hand aus fünf zufälligen Karten erstellt. \strong{Wichtig:} Da aus einem Deck von paarweise verschiedenen Karten gezogen wird, darf keine Karte doppelt vorkommen.
	
	\begin{exchinweise}
		\item Da wir \swiftinline{Suit} und \swiftinline{Rank} von \swiftinline{Int} abgeleitet haben, können wir Zufallszahlen generieren und die Enums daraus erstellen:
	
		\begin{swiftcode}
        let rndSuit = Suit(rawValue: Int(arc4random_uniform(4)))!
        let rndRank = Rank(rawValue: Int(arc4random_uniform(13)))!
        let rndCard = Card(suit: rndSuit, rank: rndRank) // Eine zufällige Spielkarte
		\end{swiftcode}
		
		\item Die Funktion \swiftinline{contains} könnte hilfreich sein, um das Vorhandensein von Karten zu überprüfen. Um diese mit \swiftinline{Card} verwenden zu können muss \swiftinline{Card} das \swiftinline{Equatable} Protokoll erfüllen. Schreibt \swiftinline{extenstion Card: Equatable {}} und dann außerhalb:
		
		\begin{swiftcode}
        func ==(lhs: Card, rhs: Card) -> Bool {
            return lhs.suit == rhs.suit && lhs.rank == rhs.rank
        }
		\end{swiftcode}
	\end{exchinweise}
	
Erstellt ein paar Poker Hände und lasst euch die \swiftinline{description} ausgeben. Habt ihr etwas gutes gezogen?

\item Implementiert nun ein weiteres Enum \swiftinline{enum Ranking: Int} mit den Fällen \swiftinline{case highCard, flush, straightFlush} usw., die ihr bspw. auf Wikipedia\linkref{http://en.wikipedia.org/wiki/List_of_poker_hands} findet.

Fügt dann dem \swiftinline{struct PokerHand} eine Computed Property \swiftinline{var ranking: Ranking} hinzu. Implementiert hier einen Algorithmus, der prüft, ob ein \emph{Flush} vorliegt. Dann soll \swiftinline{.flush} zurückgegeben werden, ansonsten einfach \swiftinline{.highCard}.
	
\item Wir können nun einige tausend Hände generieren und die Wahrscheinlichkeit für einen Flush abschätzen. Fügt einfach folgenden Code am Ende des Playgrounds ein:

\begin{swiftcode}
var rankingCounts = [Ranking : Int]()
let samples = 1000
for i in 0...samples {
    let ranking = PokerHand().ranking
    if rankingCounts[ranking] == nil {
        rankingCounts[ranking] = 1
    } else {
        rankingCounts[ranking]! += 1
    }
}

for (ranking, count) in rankingCounts {
    print("The probability of being dealt a \(ranking.description) is \(Double(count) / Double(samples) * 100)%")
}
\end{swiftcode}

Die Ausführung kann etwas dauern, justiert ggfs. \swiftinline{samples}. Stimmt die Wahrscheinlichkeit ungefähr mit der Angabe auf Wikipedia überein?

\item \strong{Extra:} Ihr könnt das Programm nun noch erweitern und versuchen, die anderen Ränge zu überprüfen. Dabei könnten Hilfsattribute wie \swiftinline{var hasFlush: Bool} oder \swiftinline{var pairCount: Int} nützlich sein. Bekommt es jemand es jemand hin, eine Funktion zu schreiben, die zwei Hände vergleicht und den Sieger bestimmt? \strong{Tipp:} Dazu könnte es hilfreich sein, die Fälle des \swiftinline{enum: Ranking} um \emph{Associated Attributes} zu erweitern.

\end{enumerate}

\end{excitem}

\end{exc}


\end{lecture}



\begin{lecture} % Lecture 3


\chapter{iOS App Architektur}

Wir haben nun die Grundlagen der Programmierung in Swift gelernt. Jetzt können wir uns der Programmierung komplexerer Apps zuwenden. Dabei lernen wir die \emph{Architektur} von iOS Apps kennen und verwenden Konzepte zur Strukturierung unseres Programmcodes, die für größerere Softwareprojekte notwendig sind.

Die grundlegende Architektur einer iOS App illustriert das Repository \url{https://github.com/ios-dev-kurs/bare} und der Abschnitt \emph{iOS App Lifecycle} im Skript. Schaut euch insbesondere auch die Commitfolge \shinline{git log} des Repositories an. Jeder Commit stellt einen Schritt vom minimal ausführbaren Code bis zu einer funktionsfähigen App mit Storyboard dar. Ein Commit wird durch seinen \emph{Hash} identifiziert, der auch von \shinline{git log} ausgegeben wird. Diesen könnt ihr verwenden, um das Verzeichnis in den Zustand zu einem bestimmten Commit zu versetzen:
\begin{shcode}
git checkout e35cec8e71ffb87d19b837cf48c12837329a6d82 # z.B. Hash des ersten Commits
\end{shcode}

Sobald unsere App startet und ein Storyboard lädt sind liegt die Verantwortung bei uns. Unsere Aufgabe ist nun das \emph{Software Engineering}. Viele Konzepte sind von der Plattform und Programmiersprache unabhängig gültig (siehe bspw. das \emph{DRY - Don't repeat yourself} Prinzip \linkref{https://de.wikipedia.org/wiki/Don’t_repeat_yourself}). Ziel ist, unseren Programmcode übersichtlich, flexibel und erweiterbar zu strukturieren. Damit vermeiden wir automatisch Fehler und verlieren uns nicht in der Komplexität des Codes.

Die iOS App Entwicklung orientiert sich konsequent am \emph{Model-View-Controller Konzept} der Programmierung oder Varianten dieses Konzepts. Es ist nicht nur in Apples Frameworks wie \swiftinline{UIKit} rigoros umgesetzt sondern stellt auch die Grundlage für die weitere Konzeption unserer Apps dar und wird auch in vielen anderen Bereichen der Softwareentwicklung verwendet. Das Konzept ist im Skript beschrieben und sollte bei Entscheidungen zur Architektur einer App stets zu Rate gezogen werden.

\skriptref{Das Model-View-Controller Konzept}


\begin{exc}

\begin{excitem}{lifetime}{Lifetime}{2}

In dieser Aufgabe zeigen wir für die Kontakte auf unseren iOS Geräten die Zeit seit ihrem Geburtstag an.

Forkt das Repository \url{https://github.com/ios-dev-kurs/lifetime} und erstellt eine Pull-Request um eure Lösung einzureichen oder Fragen zu stellen.


\begin{enumerate}

\item Die \emph{Model}-Komponente \mvcindicatormodel der App ist bereits implementiert. Wir verwenden das \swiftinline{Contacts} Framework von Apple, das Zugriff auf die Kontakte ermöglicht. In \filename{Lifetime.swift} erweitern wir die Klasse \swiftinline{CNContact} um ein Computed Attribute \swiftinline{lifetime: NSTimeInverval?}.

\mvcindicatorcontroller Um auf Kontakte zuzugreifen stellen wir Anfragen an einen \swiftinline{CNContactStore}. Das \swiftinline{AppDelegate} erstellt einen solchen und reicht ihn an den \swiftinline{ContactListViewController} weiter. Dieser lädt die Kontakte und soll sie nun anzeigen. Dazu verwaltet er eine \swiftinline{UITableView}, die nach dem \emph{Delegate}-Prinzip nach Bedarf Anfragen nach Zahl und Inhalt der anzuzeigenden Zeilen stellt. Diese Anfragen muss der \swiftinline{ContactListViewController} beantworten. Eure erste Aufgabe ist, zu diesem Zweck das \swiftinline{UITableViewDatasource} Protokoll zu implementieren.

Implementiert das Protokoll in einer Erweiterung in \filename{ContactListViewController.swift}. Die folgenden drei Methoden muss jede Implementierung des Protokolls mindestens bereitstellen:

\begin{swiftcode}
extension ContactListViewController {

    override func numberOfSectionsInTableView(tableView: UITableView) -> Int {
        return 1 // Wir zeigen die Kontakte zunächst in einer einzelnen Section an
    }

    override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return contacts.count // Für jeden Kontakt soll eine Zeile angezeigt werden
    }

    override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
        // VIEW-Komponente: Frage die Table View nach einer wiederverwendbaren Zelle
        let cell = tableView.dequeueReusableCellWithIdentifier("LifetimeCell", forIndexPath: indexPath) as! LifetimeCell
        // MODEL-Komponente: Bestimme den Kontakt für diese Zeile
        let contact = contacts[indexPath.row]
        // CONTROLLER-Komponente: Konfiguriere die Zelle nach dem Kontakt
        cell.configureForContact(contact)
        if contact.lifetime != nil {
            cell.selectionStyle = .Default
            cell.accessoryType = .DisclosureIndicator
        } else {
            cell.selectionStyle = .None
            cell.accessoryType = .None
        }
        return cell
    }

}
\end{swiftcode}

\item Es fehlt noch die \mvcindicatorview\emph{View}-Komponente, also die Zelle die wir oben bereits verwenden. Erstellt eine neue Datei \filename{LifetimeCell.swift} und platziert sie im Project Navigator unter \emph{View}. Implementiert darin die Klasse \swiftinline{class LifetimeCell: UITableViewCell}:

\begin{swiftcode}
import UIKit
import Contacts

class LifetimeCell: UITableViewCell {
    
    func configureForContact(contact: CNContact) {
        textLabel?.text = CNContactFormatter.stringFromContact(contact, style: .FullName)
        if let lifetime = contact.lifetime {
            let lifetimeFormatter = NSDateComponentsFormatter()
            lifetimeFormatter.allowedUnits = .Day
            lifetimeFormatter.unitsStyle = .Full
            detailTextLabel?.text = lifetimeFormatter.stringFromTimeInterval(lifetime)
        } else {
            detailTextLabel?.text = nil
        }
    }
    
}
\end{swiftcode}

Wir gestalten die Zelle im \filename{Main.storyboard}. Zieht aus der Object Library eine \swiftinline{UITableViewCell} auf die \swiftinline{UITableView}. Ändert im Attributes Inpector ihren \emph{Style} zu \emph{Right Detail} und gebt ihr den \emph{Identifier} \str{LifetimeCell}. Wählt dann den Identity Inspector und ändert die Klasse der Zelle zur gerade implementierten \swiftinline{LifetimeCell}. Beide Schritte sind notwendig, sodass die zuvor implementierte \swiftinline{tableView(_:cellForRowAtIndexPath:)} Methode fehlerfrei ausgeführt wird.

\item Nun könnt ihr die App ausführen und seht bereits eine Liste der Kontakte!

\mvcindicatorcontroller Wenn wir einen Kontakt antippen soll dessen Detailansicht angezeigt werden, die von einem anderen View Controller verwaltet wird. Im Skript könnt ihr euch über die \emph{View Controller Hierarchie} informieren. Der \swiftinline{ContactListViewController} wird bereits von einem \swiftinline{UINavigationController} verwaltet, den wir nun verwenden um einen \swiftinline{ContactDetailViewController} anzuzeigen.

Im \filename{Main.storyboard} können wir den Übergang zwischen den View Controllern durch eine \emph{Storyboard Segue} implementieren. Zieht mit gedrückter \keys{\ctrl}-Taste eine Line von der \str{LifetimeCell} zum \swiftinline{ContactDetailViewController} und wählt im Popup \emph{Show}. Wählt die so erstellte Segue aus und gebt ihr im Attributes Inspector den \emph{Identifier} \str{showContactDetail}.

\item Schließlich müssen wir den ausgewählten Kontakt im \swiftinline{ContactListViewController} noch an den \swiftinline{ContactDetailViewController} weitergeben. Dazu dient die \swiftinline{prepareForSegue(_:sender:)} Methode:
\begin{swiftcode}
    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        switch segue.identifier! {

        case "showContactDetail":
            guard let indexPath = self.tableView.indexPathForSelectedRow else { break }
            let contact = contacts[indexPath.row]
            let contactDetailViewController = segue.destinationViewController as! ContactDetailViewController
            contactDetailViewController.contact = contact
            
        default:
            break
        }
    }
\end{swiftcode}

Sehr ähnlich könnt ihr noch die \swiftinline{shouldPerformSegueWithIdentifier(_:sender:)} Methode implementieren und für \str{showContactDetail} \swiftinline{contact.lifetime != nil} zurückgeben, sodass die Detailansicht nur für Kontakte mit gültigem Geburtstag angezeigt wird.

\item Unsere App zeigt uns jetzt, wie lang unsere Kontakte schon leben!

Statt den \emph{Right Detail} Stil für die \swiftinline{LifetimeCell} zu verwenden könnt ihr die Zelle natürlich auch selbst gestalten. Wenn ihr noch Erweiterungen einbauen möchtet für die ihr weitere Attribute von \swiftinline{CNContact} benötigt, wie bspw. \swiftinline{CNContactImageDataKey}, müsst ihr diese der Liste \swiftinline{requiredContactKeysToFetch} in \swiftinline{ContactListViewController} hinzufügen, sodass sie ebenfalls aus dem \swiftinline{CNContactStore} geladen werden.

Schickt eine Pull-Request wenn ihr mit eurer App zufrieden seid oder um Fragen zu stellen.

\end{enumerate}

\end{excitem}

\end{exc}


\end{lecture}


\end{document} %%% MARKER %%%



\begin{lecture}


\chapter{Seasonizer}

Mit den Apps der vergangenen Vorlesungen haben wir die Grundlagen der Programmierung für iOS Geräte und einige wichtige Architekturkonzepte kennengelernt. Mit diesem Wissen lässt sich bereits ein Großteil der zur Verfügung stehenden Frameworks anwenden und viele Funktionen, die iOS Geräte bieten, in unsere eigenen Apps integrieren.

%Aus gegebenem Anlass implementieren wir in dieser App einige häufig verwendete Funktionen wie Multi-Touch Gesten und Kamera Integration, um beim nächsten Familienfest nicht nur mit unseren neu erworbenen Programmierfähigkeiten anzugeben, sondern auch noch Fotos von Familienmitgliedern festlich dekorieren zu können \abbref{img:seasonizer}.

Zusammenfassend implementieren wir in dieser App einige häufig verwendete Funktionen wie Multi-Touch Gesten und Kamera Integration, um beim nächsten Familienurlaub nicht nur mit unseren neu erworbenen Programmierfähigkeiten anzugeben, sondern auch noch Fotos von Familienmitgliedern sommerlich dekorieren zu können \abbref{img:seasonizer}.

\includegraphicsc[\iphonewidth]{img/seasonizer_summer.png}{img:seasonizer}{Mit der Seasonizer App lassen sich Freunde und Familienmitglieder sommerlich dekorieren.}

\subsubsection{Funktionen der Seasonizer App [4++~P.]}

\begin{itemize}
	\item Die App besitzt eine Hauptansicht mit Navigation Bar und Toolbar. Den Inhalt füllt eine Image View für das Foto und eine darüberliegende View mit transparentem Hintergrund für die Accessories. [1~P.]
	\item Es gibt einen Button in der Toolbar, mit dem ein Foto von der Kamera oder Foto Bibliothek ausgewählt werden kann, das anschließend von der Image View angezeigt wird. [1~P.]
	\item Ein weiterer Button zeigt modal eine Liste von Accessories an. Wird ein Accessory ausgewählt, wird es der Hauptansicht hinzugefügt. [1~P.]
	\item Die Accessories lassen sich mit Gesten verschieben, skalieren, drehen und löschen. [1~P.]
	\item Mit einem Action Button kann das Bild über verschiedene Kanäle wie Nachrichten, Email oder Facebook verteilt werden. [1~P.]
	\item Die Elemente wie Bild und Accessories werden gespeichert und beim nächsten Start der App wiederhergestellt. [1~P.]
	\item Ein Toolbar Button dient dem Zurücksetzen der Benutzeroberfläche. [1~P.]
	%\item [extra] Es schneit in der App!
	\item Implementiert, was euch einfällt! Ich bin auf eure Ideen gespannt. [++~P.]
\end{itemize}

Anders als für die bisherigen Apps wird es an dieser Stelle keine vollständige Schritt-für-Schritt Anleitung geben. Versucht stattdessen, die Funktionen der App zu implementieren, indem ihr die folgenden Hinweise und die Informationen der bisherigen Themen anwendet. Ich stehe dabei natürlich jederzeit gerne für Fragen zur Verfügung.

\subsubsection{Hinweise}

\begin{itemize}

\item Wenn ihr mit dem \emph{Single View} Template beginnt, bietet es sich an, dem View Controller der Hauptansicht zunächst einen sinnvollen Namen wie \swiftinline{CanvasViewController} zu geben. Verwendet außerdem den Project Name \str{Seasonizer}.

\item \strong{Navigation Bar und Toolbar} lassen sich sehr einfach anzeigen, wenn ein Navigation Controller verwendet wird. Dieser besitzt ein Attribut \emph{Shows Toolbar}, das im Interface Builder aktiviert werden kann. Buttons lassen sich dann als Objekte der \swiftinline{UIBarButtonItem} Klasse aus der Object Library einem Navigation Item hinzufügen. \swiftinline{UIBarButtonItem} bietet bereits viele Stile wie \swiftinline{UIBarButtonSystemItemCamera} zur Auswahl im Attributes Inspector an.

\item Die Auswahl zwischen \strong{Kamera und Foto Bibliothek} lässt sich sinnvoll mit einem \swiftinline{UIAlertController} implementieren. Den Zugriff auf Kamera oder Foto Bibliothek übernimmt dann ein entsprechend konfigurierter \swiftinline{UIImagePickerController} aus \swiftinline{UIKit}.

\begin{swiftcode}
    @IBAction func cameraButtonPressed(sender: AnyObject) {
        let alertController = UIAlertController(title: nil, message: nil, preferredStyle: .ActionSheet)
        if UIImagePickerController.isSourceTypeAvailable(.Camera) {
            alertController.addAction(UIAlertAction(title: "Take Photo", style: .Default, handler: { action in
                self.presentImagePickerWithSourceType(.Camera)
            }))
        }
        if UIImagePickerController.isSourceTypeAvailable(.PhotoLibrary) {
            alertController.addAction(UIAlertAction(title: "Choose from Photo Library", style: .Default, handler: { action in
                self.presentImagePickerWithSourceType(.PhotoLibrary)
            }))
        }
        alertController.addAction(UIAlertAction(title: "Cancel", style: .Cancel, handler: nil))
        self.presentViewController(alertController, animated: true, completion: nil)
    }
    func presentImagePickerWithSourceType(sourceType: UIImagePickerControllerSourceType) {
        let imagePicker = UIImagePickerController()
        imagePicker.sourceType = sourceType
        imagePicker.delegate = self
        self.presentViewController(imagePicker, animated: true, completion: nil)
    }
\end{swiftcode}

\item Der \swiftinline{UIImagePickerController} verwendet das Delegate Konzept um die Auswahl eines Fotos zu kommunizieren. Wir setzen den View Controller selbst als Delegate, also muss dieser das \swiftinline{UIImagePickerControllerDelegate} implementieren:

\begin{swiftcode}
class CanvasViewController: UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
    // ...
    func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [NSObject : AnyObject]) {
        self.photoImageView.image = info[UIImagePickerControllerOriginalImage] as? UIImage
        picker.dismissViewControllerAnimated(true, completion: nil)
    }
    func imagePickerControllerDidCancel(picker: UIImagePickerController) {
        picker.dismissViewControllerAnimated(true, completion: nil)
    }
\end{swiftcode}

\item Wir modellieren die Accessories in dieser App als \swiftinline{struct Accessory}. Accessories besitzen jeweils ein Bild einen Titel. Erstellt eine Liste von Accessories im App Delegate und gebt diese Liste durch die View Controller Hierarchie weiter an den \swiftinline{CanvasViewController}.

\item Um modal einen weiteren View Controller mit Titelleiste für die \strong{Accessory Liste} anzuzeigen, kann dieser wiederum in einem Navigation Controller verpackt werden \abbref{img:seasonizer_ui}. Es sollte eine dynamische Table View in einer Subklasse \swiftinline{AccessoryListViewController: UITableViewController} verwendet werden, um die Liste der verfügbaren Accessories anzuzeigen.

\includegraphicsc{img/seasonizer_ui.png}{img:seasonizer_ui}{Navigation Controller bieten eine einfache Möglichkeit, Navigationsleisten und Toolbars anzuzeigen}

\item Der \swiftinline{AccessoryListViewController} benötigt eine Liste von Accessories, die er präsentieren soll, sowie eine Möglichkeit, das ausgewählte Accessory wiederum dem präsentierenden View Controller zu kommunizieren. Dazu könnt ihr entweder ein eigenes Delegate Protokoll implementieren, oder Unwind Segues verwenden. Im Skript findet ihr ein Beispiel für die Implementierung eines Delegate Protokolls. Wenn ihr lieber Unwind Segues verwenden möchtet, müsst ihr die Liste von Accessories zunächst in der \swiftinline{prepareForSegue:} Methode weitergeben und dann das ausgewählt Accessory in der Unwind Methode, bspw. \swiftinline{unwindToCanvas:}, auslesen.

\item Wenn der \swiftinline{CanvasViewController} nun ein \swiftinline{Accessory} bekommt, soll es durch eine View repräsentiert werden, die auf einer transparenten View \swiftinline{accessoryOverlayView} über dem Bild angezeigt wird. Erstellt dafür zunächst eine Subklasse \swiftinline{AccessoryView: UIImageView}:
\begin{swiftcode}
// AccessoryView.swift
import UIKit

class AccessoryView: UIImageView {    
    init(accessory: Accessory) {
        super.init(image: accessory.image)
    }
    required init(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}	
\end{swiftcode}

	Diese könnt ihr dann verwenden, um eine Repräsentation des ausgewählten Accessory zu erstellen:
\begin{swiftcode}
        let accessoryView = AccessoryView(accessory: accessory)
        accessoryView.center = accessoryOverlayView.convertPoint(accessoryOverlayView.center, fromView: accessoryOverlayView.superview)
        self.addAccessoryView(accessoryView) // muss noch implementiert werden
\end{swiftcode}

\item Den Code zum Hinzufügen der Accessory View zur View Hierarchie lagern wir in eine Methode \swiftinline{addAccessoryView:} aus, in der wir die View zunächst konfigurieren können.

Für die Manipulation der Accessories mit Gesten können wir \strong{Gesture Recognizer} verwenden. UIKit implementiert einige hilfreiche Subklassen von \swiftinline{UIGestureRecognizer}, die bestimmt Multi-Touch Events auf der ihr zugewiesenen View erkennen und ihr Delegate Objekt darüber informieren. Also können wir den Canvas View Controller als Empfänger des \swiftinline{UIGestureRecognizerDelegate} Protokolls markieren, Gesture Recognizer in der \swiftinline{addAccessory:} Methode hinzufügen und die Delegate Methoden zum Bewegen, Skalieren, Rotieren und Löschen der Accessories implementieren.

\begin{swiftcode}
    func addAccessoryView(accessoryView: AccessoryView) {
        self.accessoryOverlayView.addSubview(accessoryView)
        accessoryView.userInteractionEnabled = true
        // Bewegen
        let panGR = UIPanGestureRecognizer(target:self, action:"pan:")
        panGR.delegate = self
        accessoryView.addGestureRecognizer(panGR)
        // Skalieren
        let pinchGR = UIPinchGestureRecognizer(target:self, action:"pinch:")
        pinchGR.delegate = self
        accessoryView.addGestureRecognizer(pinchGR)
        // Drehen
        let rotateGR = UIRotationGestureRecognizer(target:self, action:"rotate:")
        rotateGR.delegate = self
        accessoryView.addGestureRecognizer(rotateGR)
        // Löschen
        let tapGR = UILongPressGestureRecognizer(target:self, action:"tap:")
        tapGR.delegate = self
        accessoryView.addGestureRecognizer(tapGR)
    }
    
    func gestureRecognizer(gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWithGestureRecognizer otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true // Gesture Recognizer unterbrechen andernfalls die Erkennung einer Geste bei der Erkennung einer anderen
    }
    
    func pan(sender: UIPanGestureRecognizer) {
        if let accessoryView = sender.view {
            accessoryView.superview?.bringSubviewToFront(accessoryView)
            let translation = sender.translationInView(accessoryView.superview!)
            accessoryView.center = CGPoint(x: accessoryView.center.x + translation.x, y: accessoryView.center.y + translation.y)
            sender.setTranslation(CGPointZero, inView: accessoryView.superview!)
        }
    }
    func pinch(sender: UIPinchGestureRecognizer) {
        if let accessoryView = sender.view {
            accessoryView.superview?.bringSubviewToFront(accessoryView)
            accessoryView.transform = CGAffineTransformScale(accessoryView.transform, sender.scale, sender.scale);
            sender.scale = 1
        }
    }
    func rotate(sender: UIRotationGestureRecognizer) {
        if let accessoryView = sender.view {
            accessoryView.superview?.bringSubviewToFront(accessoryView)
            accessoryView.transform = CGAffineTransformRotate(accessoryView.transform, sender.rotation);
            sender.rotation = 0
        }
    }
    private var selectedAccessoryView: UIView?
    func tap(sender: UILongPressGestureRecognizer) {
        if sender.state != .Began {
            return
        }
        if let accessoryView = sender.view {
            self.becomeFirstResponder()
            let menuController = UIMenuController.sharedMenuController()
            menuController.menuItems = [ UIMenuItem(title: "Remove", action:"removeAccessoryButtonPressed:") ]
            menuController.setTargetRect(CGRect(x: accessoryView.center.x, y: accessoryView.center.y, width: 0, height: 0), inView: accessoryView.superview!)
            menuController.setMenuVisible(true, animated: true)
            self.selectedAccessoryView = accessoryView
        }
    }
    override func canBecomeFirstResponder() -> Bool {
        return true
    }
    func removeAccessoryButtonPressed(sender: AnyObject) {
        if let accessoryView = self.selectedAccessoryView {
            accessoryView.removeFromSuperview()
        }
    }
\end{swiftcode}

Hier sei angemerkt, dass wir aufgrund des Zusammenspiels verschiedener Gesture Recognizer jeweils Delta-Bewegungen verwenden und auf die View anwenden, indem der jeweilige Gesture Recognizer bei jedem Methodenaufruf zurückgesetzt wird.

Der \swiftinline{UILongPressGestureRecognizer} zeigt einen speziellen \swiftinline{UIMenuController} zur Darstellung eines \str{Entfernen} Buttons. Damit dieser korrekt angezeigt wird, muss die \swiftinline{canBecomeFirstResponder} Methode implementiert werden.

\item Die Integration eines \strong{Activity Sheets} zum Teilen von Inhalten ist denkbar einfach. \swiftinline{UIKit} stellt dafür den \swiftinline{UIActivityViewController} zur Verfügung, der eine Liste von Datenobjekten annimmt und abhängig vom Typ der Daten eine Auswahl von Kanälen zum Teilen anzeigt. Das Bild sollte in einer Computed Property stets neu generiert werden.

\begin{swiftcode}
    @IBAction func actionButtonPressed(sender: AnyObject) {
        let activityViewController = UIActivityViewController(activityItems: [ self.renderedPicture ], applicationActivities: nil)
        self.presentViewController(activityViewController, animated: true, completion: nil)
    }
    var renderedPicture: UIImage {
        UIGraphicsBeginImageContextWithOptions(self.view.frame.size, true, 0)
        self.view.drawViewHierarchyInRect(self.view.bounds, afterScreenUpdates: true)
        let renderedPicture = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return renderedPicture
    }
\end{swiftcode}

\item Um die Benutzeroberfläche vollständig wiederherstellen zu können, müssen wir sowohl das Foto als auch die hinzugefügten Accessories speichern. Als Methode der Datenspeicherung bietet sich in dieser App das \strong{State Preservation} System an, doch auch die \strong{User Defaults} Mechanik könnte stattdessen verwendet werden.

Zur Speicherung der Accessories müssen wir in der \swiftinline{AccessoryView: UIImageView} Klasse zunächst das \swiftinline{NSCoding} Protokoll implementieren. Dieses Protokoll bietet die Möglichkeit, Objekte als \swiftinline{NSData} zu serialisieren. \swiftinline{UIImageView} implementiert dieses Protokoll bereits, speichert aber das angezeigte Bild nicht. Daher müssen wir in der Subklasse lediglich die beiden Schlüsselmethoden überschreiben:

\begin{swiftcode}
// AccessoryView.swift
import UIKit

class AccessoryView: UIImageView {
    init(accessory: Accessory) {
        super.init(image: accessory.image)
    }
    override func encodeWithCoder(aCoder: NSCoder) {
        if let image = self.image {
            aCoder.encodeObject(UIImagePNGRepresentation(image), forKey: "image")
        }
        super.encodeWithCoder(aCoder)
    }
    required init(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        if let imageData = aDecoder.decodeObjectForKey("image") as? NSData {
            self.image = UIImage(data: imageData)
        }
    }
}
\end{swiftcode}

\item Nun müssen wir das State Preservation System lediglich noch aktivieren. Dazu müssen zwei Methoden im App Delegate implementiert werden:
\begin{swiftcode}
    func application(application: UIApplication, shouldSaveApplicationState coder: NSCoder) -> Bool {
        return true
    }
    func application(application: UIApplication, shouldRestoreApplicationState coder: NSCoder) -> Bool {
        return true
    }	
\end{swiftcode}

Außerdem muss jeder View Controller, der wiederhergestellt werden soll, sowohl alle View Controller in seiner View Controller Hierarchie, einen \swiftinline{restorationIdentifier} besitzen. Dieser kann im Storyboard im Identity Inspector zugewiesen werden. Der Navigation Controller und der Canvas View Controller benötigen also einen solchen.

Schließlich muss nur noch die Wiederherstellung des Canvas View Controllers konfiguriert werden. Dies geschieht in zwei Methoden, die wir überschreiben müssen:
\begin{swiftcode}
    // in CanvasViewController.swift
    override func encodeRestorableStateWithCoder(coder: NSCoder) {
        if let photo = photoImageView.image {
            let imageData = UIImagePNGRepresentation(photo)
            coder.encodeObject(imageData, forKey: "photo")
        }
        coder.encodeObject(NSKeyedArchiver.archivedDataWithRootObject(self.accessoryViews), forKey: "accessoryViews")
        super.encodeRestorableStateWithCoder(coder)
    }
    override func decodeRestorableStateWithCoder(coder: NSCoder) {
        if let photoData = coder.decodeObjectForKey("photo") as? NSData {
            photoImageView.image = UIImage(data: photoData)
        }
        if let accessoryViewsData = coder.decodeObjectForKey("accessoryViews") as? NSData {
            let accessoryViews = NSKeyedUnarchiver.unarchiveObjectWithData(accessoryViewsData) as! [AccessoryView]
            for accessoryView in accessoryViews {
                self.addAccessoryView(accessoryView)
            }
        }
        super.decodeRestorableStateWithCoder(coder)
    }	
\end{swiftcode}

Hier verwenden wir wieder die \swiftinline{addAccessoryView:} Methode um die Accessories der View Hierarchie hinzuzufügen und die Gesture Recognizer zu erzeugen.

\item Implementieren wir einen weiteren Toolbar Button, der die Benutzeroberfläche bei Betätigung \strong{zurücksetzt}, sollte zunächst eine Schaltfläche zur Bestätigung erscheinen. Dazu eignet sich wieder ein \swiftinline{UIAlertController} im \swiftinline{.ActionSheet} Stil.

\end{itemize}


\subsubsection{Der Seasonizer auf GitHub}

Auf GitHub findet ihr eine Beispielimplementierung des Seasonizers \linkref{https://github.com/iOS-Dev-Kurs/seasonizer}, die ihr als Referenz verwenden und auch weiterentwickeln könnt.

Haltet ihr eure Änderungen für so genial oder notwendig, dass sie in mein Original Repository übernommen werden sollten, könnt ihr mir über die GitHub Webseite eine \strong{Pull Request} schicken, die mich auffordert, einen Merge mit den Änderungen durchzuführen. In dieser Form kann ein Open Source Programmierprojekt weltweit von interessierten Entwicklern weiterentwickelt werden. Und dem Seasonizer sind damit keine Grenzen gesetzt.

\end{lecture}


\end{document}
