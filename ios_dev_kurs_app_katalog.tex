\documentclass[parskip=half, final]{scrreprt}

\input{include/variables}
\input{include/style}
\input{include/code_listing}

\renewcommand{\doctype}{App Katalog}
\renewcommand{\shortdoctype}{App Katalog}

\begin{document}

\maketitle

\tableofcontents


\chapter{Einleitung}

\section{Über dieses Dokument}

Dieser App Katalog enthält Schritt-für-Schritt Anleitungen für die im Rahmen unseres Kurses erstellten Apps sowie die wöchentlich zu bearbeitenden Übungsaufgaben und wird im Verlauf des Semesters kapitelweise auf der Vorlesungswebseite \linkref{http://ios-dev-kurs.github.io/} zur Verfügung gestellt.

Er dient jedoch nur als Ergänzung zum parallel verfügbaren \strong{Skript}, auf das hier häufig verwiesen wird. Dort sind die Erläuterungen zu den verwendeten Technologien, Methoden und Begriffen zu finden.


\section{Workflow mit Git}\label{git_workflow}

Wir arbeiten in diesem Kurs mit der Versionskontroll-Software Git und der Software\-entwicklungs-Plattform GitHub \linkref{https://github.com/}. Mit diesen Werkzeugen kann ich euch Beispielprojekte und Aufgaben bereitstellen, die ihr bearbeiten und mir für Kommentare wieder zur Verfügung stellen könnt. Gleichzeitig lernt ihr dabei direkt den Umgang mit zwei der wichtigsten Werkzeuge in der modernen Softwareentwicklung.

Mit Git können wir Änderungen an einem Projekt, oder \emph{Repository}, in regelmäßigen Abständen in \emph{Commits} speichern. Dann können wir jederzeit zu vorherigen Commits zurückkehren und Änderungen vergleichen. Wer die Speicherpunkte bei Super Mario kennt weiß so etwas zu schätzen.

Außerdem ermöglicht uns Git mit anderen Entwicklern zusammenzuarbeiten. Dazu können wir das Repository auf einem Server wie GitHub bereitstellen. Speichert ein anderer Entwickler Commits in dem Repository, können wir dessen Änderungen mit einem \emph{Merge} mit unseren zusammenführen und dabei gegebenenfalls Konflikte beheben. So wird an Softwareprojekten weltweit zusammengearbeitet.

Da Git ein Kommandozeilenprogramm ist, bedarf es sicherlich einer Eingewöhnung. Wenn ihr noch wenig Erfahrung im Umgang mit der Komandozeile habt könnt ihr zum Einstieg die GitHub Desktop App \linkref{https://desktop.github.com} verwenden, mit der ihr Git über eine graphische Oberfläche bedienen könnt.

\subsection{Ein Repository forken, klonen und bearbeiten}\label{fork_and_clone}

Ich stelle Beispielprojekte und Aufgaben in Repositories wie diesem \linkref{https://github.com/ios-dev-kurs/helloworld} bereit. Verfahrt wie folgt, um es zum Bearbeiten herunterzuladen:

\begin{enumerate}

\item Erstellt einen GitHub Account \linkref{https://github.com/join}, wenn ihr noch keinen habt. Ladet euch die GitHub Desktop App herunter, wenn ihr eine graphische Oberfläche der Kommandozeile vorzieht.

\item Ihr habt nur Lese-Zugriff auf mein Repository. Ihr müsst daher erst einen \emph{Fork} \linkref{https://guides.github.com/activities/forking/} des Repositories erstellen und es damit auf euren Account kopieren. Klickt dazu einfach auf den \emph{Fork} Button auf der Repository-Seite.

\item Euren Fork könnt ihr nun nach Belieben bearbeiten. In diesem Beispiel ist das Fork-Repository unter der URL \url{https://github.com/dein-username/helloworld} verfügbar. Ihr könnt die Kommandozeile oder die GitHub Desktop App verwenden um das Repository herunterzuladen, oder zu \emph{klonen} \linkref{http://gitref.org/creating/\#clone}. Im Terminal lautet der Befehl dazu:
\begin{shcode}
git clone https://github.com/dein-username/helloworld
\end{shcode}

\item Nun könnt ihr an dem Projekt arbeiten. Mit folgendem Befehlt könnt ihr jederzeit überprüfen, welche Dateien sich geändert haben:
\begin{shcode}
git status
\end{shcode}

\item Speichert in regelmäßigen Abständen \emph{Commits} \linkref{http://gitref.org/basic/\#commit}. Jeder Arbeitsschritt sollte durch einen Commit repräsentiert werden. Achtet darauf, dass das Projekt bei jedem Commit funktionsfähig ist. In der Kommandozeile erstellt ihr einen Commit wie folgt:
\begin{shcode}
# Status überprüfen
git status
# Alle Änderungen dem nächsten Commit hinzufügen
git add --all
# Commit durchführen
git commit -m "Kurze Beschreibung der Änderungen"
\end{shcode}

\item Ihr könnt euer lokales Repository jederzeit mit eurem Repository auf GitHub abgleichen. Daher könnt ihr auch problemlos auf verschiedenen Rechnern an einem Projekt arbeiten. Führt einen \emph{Push} \linkref{http://gitref.org/remotes/\#push} oder \emph{Pull} \linkref{http://gitref.org/remotes/\#pull} in der Kommandozeile aus, oder klickt den \emph{Sync} Button in der GitHub Desktop App:
\begin{shcode}
# Fortschritt auf GitHub veröffentlichen
git push
# Änderungen von GitHub herunterladen
git pull
\end{shcode}

\end{enumerate}


\subsection{Eine Aufgabe per Pull-Request einreichen}\label{pull_request}

Habt ihr eine Aufgabe fertig und möchtet Sie einreichen, oder wenn ihr Hilfe benötigt, erstellt eine \emph{Pull-Request} \linkref{https://help.github.com/articles/creating-a-pull-request/}. Damit erhalte ich eine Benachrichtigung mit den Änderungen eures Forks im Vergleich zu meinem Original-Repository. Geht wie folgt vor:

\begin{enumerate}

\item Speichert eure Änderungen in einem Commit und veröffentlicht sie auf GitHub, wenn ihr es noch nicht getan habt.

\item Klickt auf der Repository-Seit den Button \emph{New Pull Request}, überprüft die Änderungen und klickt dann \emph{Create Pull Request}.

\item Gebt der Pull-Request einen Titel und beschreibt kurz die Änderungen. Erwähnt, wenn etwas nicht funktioniert, sodass ich euch helfen kann. Klickt schließlich auf \emph{Create Pull Request}.

\end{enumerate}




\begin{lecture} % Lecture 1


\chapter{Hello World}

Was ist schon ein Programmierkurs, der nicht mit einem klassischen \emph{Hello World} Programm beginnt? Wir werden jedoch noch einen Schritt weitergehen und diesen Gruß graphisch vom iOS Simulator und, soweit vorhanden, direkt von unseren eigenen iOS Geräten ausgeben lassen. Dabei stoßen wir auf unseren ersten \emph{Swift} Code und lernen die IDE \emph{Xcode} kennen. Wir arbeiten außerdem direkt mit der Versionskontroll-Software \emph{Git}, einem der Grundbausteine nahezu jedes Softwareprojekts.

\skriptref{Xcode, Programmieren in Swift, Versionskontrolle mit Git} sowie das Buch \emph{The Swift Programming Language} \linkref{https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/}


\section{"{}Hello World!"{} auf Simulator und Gerät}

\begin{enumerate}

\item Ich habe ein Beispielprojekt bereitgestellt, anhand dessen wir einen ersten Blick auf die Programmierung einer iOS App werfen. Das Ziel ist, das Projekt herunterzuladen, eine erste, einfache App zu schreiben und mir das Ergebnis für etwas \emph{konstruktive Kritik} zur Verfügung zu stellen. Dazu verwenden wir die Versionskontroll-Software \emph{Git} und die Softwareentwicklungs-Plattform \emph{GitHub}, die zu den Werkzeugen gehören, auf denen Softwareprojekte weltweit aufbauen und ohne die moderne Programmierung kaum noch denkbar ist.

Die erste Anweisung lautet:

\strong{\emph{Klont} einen \emph{Fork} des \emph{Repositories} \url{https://github.com/ios-dev-kurs/helloworld}.}

Wenn ihr noch mit keinem dieser Begriffe etwas anfangen könnt, seid beruhight: Wir werden noch so viel mit Git und GitHub arbeiten, dass ihr am Ende dieses Kurses Experten im Umgang damit seid. Befolgt zunächst einfach die Anweisungen in \autoref{fork_and_clone} \emph{Workflow mit Git} bis ihr das Beispielprojekt heruntergeladen habt.

\item Öffnet das Xcode-Projekt \filename{HelloWorld.xcodeproj} und macht euch mithilfe des Kapitels \emph{Xcode} im Skript mit der Benutzeroberfläche vertraut. In der Toolbar oben findet ihr auf der linken Seite die Steuerelemente des Compilers. Wählt das \emph{Target} \emph{HelloWorld} und ein Zielsystem, bspw. den \emph{iPhone 6s} Simulator, und klickt die \strong{\emph{Build \& Run}} Schaltfläche. Das Target wird nun kompiliert und generiert ein \emph{Product}, also unsere App, die im Simulator ausgeführt wird. Das Tastenkürzel für \emph{Build \& Run} in Xcode ist \keys{\cmd + R}.

\item Besonders spannend ist diese App natürlich noch nicht. Das ändern wir jetzt spektakulär, indem wir unseren \strong{ersten Swift Code} schreiben um eine Ausgabe hinzuzufügen. Wählt die Datei \filename{AppDelegate.swift} links im \emph{Project Navigator} aus.

\item Die Methode \swiftinline{application(_:didFinishLaunchingWithOptions:)} wird zu Beginn der Ausführung der App aufgerufen. Ersetzt den Kommentar dort mit einem Gruß zur Ausgabe in der Konsole:

\begin{swiftcode}
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
    print("Hello World!")
    return true
}
\end{swiftcode}

\item Wenn wir unsere App nun erneut mit \emph{Build \& Run} \keys{\cmd + R} kompilieren und ausführen, sehen wir den Text \str{Hello World!} in der Konsole. Dazu wird der zweigeteilte Debug-Bereich unten automatisch eingeblendet \abbref{img:helloworld_helloworld}. Ist der Konsolenbereich zunächst versteckt, kann er mit der Schaltfläche in der rechten unteren Ecke angezeigt werden. Außerdem wird links automatisch zum Debug Navigator gewechselt, wenn eine App ausgeführt wird, in dem CPU- und Speicherauslastung überwacht werden können und Fehler und Warnungen angezeigt werden, wenn welche auftreten.

\includegraphicsc[\screenshotwidth]{img/helloworld_helloworld.png}{img:helloworld_helloworld}{In der Konsole des Debug-Bereichs werden Ausgaben der laufenden App angezeigt}

\item Wenn ihr ein iOS Gerät dabei habt, verbindet es per USB-Kabel mit eurem Mac und wählt das Gerät in der Toolbar als Zielsystem aus. Mit einem \emph{Build \& Run} wird die App nun kompiliert, auf dem Gerät installiert und ausgeführt. In der Konsole erscheint wieder die Ausgabe \str{Hello World!}, diesmal direkt vom Gerät ausgegeben.

\end{enumerate}


\section{Graphisches "{}Hello World!"{}}

Natürlich wird ein Benutzer unserer App von den Ausgaben in der Konsole nichts mitbekommen. Diese dienen bei der Programmierung hauptsächlich dazu, Abläufe im Code nachzuvollziehen und Fehler zu finden. Unsere App ist also nur sinnvoll, wenn wir die Ausgaben auch auf dem Bildschirm darstellen können.

\skriptref{Xcode / Interface Builder}

\begin{enumerate}

\item Zur Gestaltung der Benutzeroberfläche oder \emph{User Interface (UI)} verwenden wir ein \emph{Storyboard}. Wählt im Project Navigator die Datei \emph{main.storyboard} aus.

\item Der Editor-Bereich zeigt nun den Interface Builder. In diesem Modus möchten wir häufig eine angepasste Konfiguration des Xcode-Fensters verwenden, es bietet sich also an, mit \keys{\cmd + T} einen neuen Tab zu öffnen. Blendet dann mit den Schaltflächen auf der rechten Seite der Toolbar den Navigator- und Debug-Bereich links und unten aus und den Inspektor rechts ein. Wählt dort außerdem zunächst den Standard-Editor, also die linke der drei Schaltflächen \abbref{img:helloworld_ib}.

\includegraphicsc[\screenshotwidth]{img/helloworld_ib.png}{img:helloworld_ib}{Für den Interface Builder verwenden wir eine angepasste Fensterkonfiguration mit dem Inspektor anstatt des Navigators}

\item Unser UI besteht bisher nur aus einer einzigen Ansicht, oder \emph{Scene}. Ein Pfeil kennzeichnet die Scene, die zum Start der App angezeigt wird. Im Inspektor rechts ist unten die Object Library zu finden. Wählt den entsprechenden Tab aus, wenn er noch nicht angezeigt wird \abbref{img:helloworld_ib}.

\item Durchsucht die Liste von Interfaceelementen nach einem Objekt der Klasse \swiftinline{UILabel}, indem ihr das Suchfeld unten verwendet, und zieht ein Label irgendwo auf die erste Scene. Doppelklickt auf das erstellte Label und tippt \str{Hello World!}.

\item Ein \emph{Build \& Run} mit einem iPhone-Zielsystem zeigt diesen Gruß nun statisch auf dem Bildschirm an.

\item Habt ihr das Label im Interface Builder ausgewählt, zeigt der Inspektor Informationen darüber an. Im \emph{Identity Inspector} könnt ihr euch vergewissern, dass das Objekt, was zur Laufzeit erzeugt wird und das Label darstellt, ein Objekt der Klasse \swiftinline{UILabel} ist. Im \emph{Attributes Inspector} stehen viele Optionen zur Auswahl, mit denen Eigenschaften wie Inhalt, Schrift und Farbe des Labels angepasst werden können.

\item Natürlich möchten wir unser UI zur Laufzeit mit Inhalt füllen und den Benutzer mit den Interfaceelementen interagieren lassen können. Zieht ein \swiftinline{UIButton}- und \swiftinline{UITextField}-Objekt auf die Scene und positioniert sie passend \abbref{img:helloworld_ui}. Mit dem Attributes Inspector könnt ihr dem Button nun den Titel \str{Say Hello!} geben und für das Text Field einen Placeholder \str{Name} einstellen.

\includegraphicsc[.6\textwidth]{img/helloworld_ui.png}{img:helloworld_ui}{Mit einem Text Field, einem Button und einem Label erstellen wir ein simples UI}

\item Damit sich das Layout an jede Bildschirmgröße automatisch anpasst, verwenden wir nun \emph{Auto Layout}. Die Schaltflächen dazu findet ihr in der unteren rechten Ecke des Interface Builder Editors. Markiert mit gedrückter \keys{\cmd}-Taste die drei Interfaceelemente und klickt auf das Linke der Symbole mit dem Titel \emph{Stack}, sodass die Elemente in eine \emph{Stack View} eingebettet werden. Dieses praktische Objekt positioniert die enthaltenen Elemente automatisch relativ zueinander. Wählt die Stack View aus und konfiguriert im Attributes Inspector \emph{Axis Vertical}, \emph{Alignment Fill}, \emph{Distribution Fill} und \emph{Spacing 8}. Zusätzlich müssen wir Regeln aufstellen, wie die Stack View auf dem Bildschirm positioniert werden soll. Dazu erstellen wir \emph{Constraints} mit den beiden mittleren der Auto Layout Schaltflächen. Befestigt die Stack View links und rechts am Rand und zentriert sie vertikal.

\item Zur Laufzeit der App wird für jedes im Storyboard konfigurierte Interfaceelement ein Objekt der entsprechenden Klasse erstellt und dessen Attribute gesetzt. Um nun im Code auf die erstellten Objekte zugreifen und auf Benutzereingaben reagieren zu können, verwenden wir \emph{IBOutlets} und \emph{IBActions}.
	
Blendet den Inspektor aus und wählt stattdessen den Assistant-Editor (mittlere Schaltfläche) in der Toolbar. Stellt den Modus in der Jump bar auf \emph{Automatic}. Im Assistant wird automatisch die Implementierung des übergeordneten View Controllers eingeblendet \abbref{img:helloworld_assistant}.

\includegraphicsc[\screenshotwidth]{img/helloworld_assistant.png}{img:helloworld_assistant}{Mithilfe des Assistants können Interface-Builder und Code nebeneinander angezeigt werden.}

\item \emph{View Controller} sind Objekte einer Subklasse von \swiftinline{UIViewController}, die jeweils einen Teil der App steuern. Diese sind zentrale Bestandteile einer App, mit denen wir uns noch detailliert beschäftigen werden. Ein erster View Controller zur Steuerung dieser ersten Ansicht ist im Projekt bereits enthalten.

Fügt dieser Klasse \swiftinline{ViewController: UIViewController} Attribute für das \swiftinline{UILabel} und das \swiftinline{UITextField} hinzu und kennzeichnet diese mit \swiftinline{@IBOutlet}. Implementiert außerdem eine mit \swiftinline{IBAction} gekennzeichnete Methode, die aufgerufen werden soll, wenn der Benutzer den \swiftinline{UIButton} betätigt:

\begin{swiftcode}
import UIKit

class ViewController: UIViewController {

    @IBOutlet var nameTextfield: UITextField!
    @IBOutlet var greetingLabel: UILabel!

    @IBAction func greetingButtonPressed(sender: UIButton) {
        print("Hello World!")
    }
    
}
@end
\end{swiftcode}

\item Nun zieht mit gedrückter \keys{\ctrl}-Taste eine Linie von dem Textfeld und dem Label im Interface Builder auf das jeweilige Attribut im Code. Die Codezeile wird dabei blau hinterlegt. Zieht außerdem genauso eine Line von dem Button auf die zuvor definierte Methode. Im Connection Inspector könnt ihr die IBOutlets und IBActions eines ausgewählten Objekts betrachten und wieder entfernen. Dieser Prozess ist im Skript noch detaillierter beschrieben.

\item Versucht nun einen \emph{Build \& Run}. Betätigt ihr den Button, wird die Methode ausgeführt und der Gruß \str{Hello World!} in der Konsole ausgegeben!

\item Um die App nun alltagstauglich zu gestalten, muss dieser Gruß natürlich personalisiert und auf dem Bildschirm angezeigt werden. Dazu verwenden wir das Attribut \swiftinline{text} der Klassen \swiftinline{UITextField} und \swiftinline{UILabel} und zeigen einen personalisierten Gruß an, wenn im Text Field ein Name geschrieben steht:

\begin{swiftcode}
@IBAction func greetingButtonPressed(sender: UIButton) {
    if let name = nameTextfield.text where !name.isEmpty {
        greetingLabel.text = "Hello \(name)!"
    } else {
        greetingLabel.text = "Hello World!"
    }
}
\end{swiftcode}

Nach einem \emph{Build \& Run} erhalten wir unser erstes interaktives Interface, in dem ihr im Textfeld einen Namen eintippen könnt und persönlich begrüßt werdet \abbref{img:helloworld_final}!

\includegraphicsc[\iphonewidth]{img/helloworld_final.png}{img:helloworld_final}{Drücken wir auf den Button, werden wir persönlich begrüßt. Sehr praktisch!}

\item Die App ist fertig! Eure Eltern werden stolz auf euch sein. Gebt mir nun die Gelegenheit, eure Arbeit zu kommentieren. Wir verwendet dazu wieder Git, um die Änderungen, an denen ihr gerade gearbeitet habt, zu speichern, hochzuladen und mir zur Verfügung zu stellen. Befolgt dazu die weiteren Anweisungen in \autoref{pull_request}, bis ihr mir eine \emph{Pull-Request} geschickt habt.

\end{enumerate}

\begin{exc}

\begin{excitem}{simpleui}{Simple UI}{2}

Erstellt einen Fork des Repositories \url{https://github.com/ios-dev-kurs/simpleui} und schreibt eine App mit einigen Interfaceelementen, die etwas sinnvolles tut. Stellt mir das Ergebnis anschließend als Pull-Request zur Verfügung.

Implementiert eines der folgenden Beispiele oder eine eigene Idee. Ich freue mich auf kreative Apps!

\begin{description}
\item[Counter] Auf dem Bildschirm ist ein Label zu sehen, das den Wert eines Attributs \swiftinline{var count: Int} anzeigt, wenn eine Methode \swiftinline{updateLabel} aufgerufen wird. Buttons mit den Titeln \str{+1}, \str{-1} und \str{Reset} ändern den Wert dieses Attributs entsprechend und rufen die \swiftinline{updateLabel}-Methode auf.
\item[BMI] Nach Eingabe von Gewicht $m$ und Größe $l$ wird der Body-Mass-Index\linkref{http://de.wikipedia.org/wiki/Body-Mass-Index} $BMI=m/l^2$ berechnet und angezeigt.
\item[RGB] In drei Textfelder kann jeweils ein Wert zwischen 0 und 255 für die Rot-, Grün- oder Blau-Komponenten eingegeben werden. Ein Button setzt die Hintergrundfarbe \swiftinline{self.view.backgroundColor} entsprechend und ein weiterer Button generiert eine zufällige Hintergrundfarbe. Ihr könnt noch einen \swiftinline{UISwitch} hinzufügen, der einen Timer ein- und ausschaltet und damit die Hintergrundfarbe bei jedem Timerintervall zufällig wechselt (s. Hinweis).
\end{description}

\begin{exchinweise}
\item In der nächsten Vorlesung lernen wir die Objektorientierte Programmierung in Swift systematisch. Orientiert euch für diese Aufgabe an der \emph{HelloWorld} App und versucht die Funktionalität mit den folgenden Hinweisen zu implementieren. Wenn ihr nicht weiter kommt, schickt mir eine Pull-Request mit einem Kommentar und ich helfe euch.
\item Das Attribut \swiftinline{text} von \swiftinline{UILabel} und \swiftinline{UITextField} gibt eine \emph{optionale} Zeichenkette \swiftinline{String?} zurück. Ihr werdet euch mit solchen \emph{Optionals} solange herumärgern, bis ihr sie zu schätzen lernt. Verwendet die \emph{Optional Binding} Syntax um das Optional zu entpacken:
\begin{swiftcode}
if let name = nameTextfield.text {
    // name existiert und kann verwendet werden
} else {
    // nameTextfield.text hat keinen Wert
}
\end{swiftcode}
\item Einen \swiftinline{String} könnt ihr schnell in eine ganze Zahl \swiftinline{Int} oder eine Dezimalzahl \swiftinline{Double} umwandeln. Da dies fehlschlagen kann, gibt auch diese Operation einen Optional \swiftinline{Int?} bzw. \swiftinline{Double?} zurück, den wir entpacken müssen:
	\begin{swiftcode}
    // Sei text ein String
    if let number = Double(text) {
        // text konnte in eine Zahl number umgewandelt werden
    }
	\end{swiftcode}
\item Definiert ein Attribut wie \swiftinline{var count: Int} mit einem Startwert:
\begin{swiftcode}
class ViewController: UIViewController {

    var count: Int = 0
    
    // ...
}
\end{swiftcode}
\item Natürlich gibt es die grundlegenden Rechenoperationen \swiftinline{+-*/} in Swift. Diese Operationen können mit der Zuweisung zu einer Variablen verbunden werden, um bspw. eine Variable \swiftinline{count} um \swiftinline{1} zu erhöhen:
\begin{swiftcode}
count += 1
\end{swiftcode}
\item Eine Farbe wird durch die Klasse \swiftinline{UIColor} repräsentiert. Der \emph{Initializer} \swiftinline{UIColor(red:green:blue:alpha:)} akzeptiert jeweils Werte zwischen 0 und 1:
\begin{swiftcode}
let color = UIColor(red: 1, green: 0, blue: 0, alpha: 1) // rot
\end{swiftcode}
\item Die Funktion \swiftinline{arc4random_uniform(n)} gibt eine Pseudozufallszahl $x$ mit $0<=x<n$ aus.
\item Wenn ein \swiftinline{UISwitch} betätigt wird, kann das Event genauso mit einer IBAction verbunden werden wie das eines \swiftinline{UIButton}. Mit einem Attribut \swiftinline{var randomTimer: NSTimer?} können wir dann die Methode für das zufällige Wechseln der Hintergrundfarbe implementieren:
\begin{swiftcode}
var randomTimer: NSTimer?

@IBAction func switchValueChanged(sender: UISwitch) {
    if sender.on {
        randomTimer = NSTimer.scheduledTimerWithTimeInterval(0.15, target: self, selector: "randomButtonPressed:", userInfo: nil, repeats: true)
    } else {
        randomTimer?.invalidate()
        randomTimer = nil
    }
}
\end{swiftcode}
	Somit wird periodisch die Methode \swiftinline{randomButtonPressed(_:)} aufgerufen, die natürlich implementiert sein muss.

\end{exchinweise}

\end{excitem}

\end{exc}


\end{lecture}



\begin{lecture}


\chapter{A Swift Tour}

Für unsere ersten Apps hat eine gute Portion Intuition für ein wenig Swift Code ausgereicht. Bevor wir tiefer in die App-Programmierung einsteigen beschäftigen wir uns einmal genauer mit der Programmierung in Swift.

Apple bietet mit dem Buch \emph{The Swift Programming Language} eine hervorragende Dokumentation und ein einführendes Kapitel mit den Namen \emph{A Swift Tour}. Das Buch findet ihr sowohl online \linkref{https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/} als auch im iBooks Store \linkref{https://itunes.apple.com/de/book/swift-programming-language/id881256329?mt=11} immer in aktueller Version. Auch das letzte Kapitel \emph{Language Reference} ist sehr spannend wenn ihr euch für den detaillierten Aufbau der Sprache und deren Grammatik interessiert.

Löst die Übungsaufgaben mit eurem Wissen aus der Vorlesung und den zugehörigen Materialien auf der Vorlesungwebseite. Zieht zuerst das Buch \emph{The Swift Programming Language} zu Rate wenn ihr nicht weiterkommt. Schickt mir bei weiteren Fragen eine Pull-Request oder einen Xcode Playground per Email.

\strong{Xcode Playgrounds} eignen sich hervorragend um Swift Code auszuprobieren und um Code zu schreiben der die Infrastruktur einer App nicht erfordert, wie bspw. die Übungsaufgaben \emph{Fibonacci}, \emph{Primzahlen} und \emph{Poker}. Erstellt einen Playground mit \menu{File > New > Playground...} oder \keys{\cmd + \shift + \Alt + N}.

Die Übungsaufgaben \emph{Fibonacci} und \emph{Primzahlen} sind optional und an Kursteilnehmer gerichtet, die noch wenig oder keine Programmierkenntnisse mitbringen. Auch erfahrene Programmierer können aber anhand dieser Aufgaben die Swift Syntax kennenlernen und versuchen die Aufgaben so \emph{swifty} wie möglich zu lösen.

\begin{exc}

\begin{excitem*}{fibonacci}{Fibonacci}{1}

Schreibt in einem Xcode Playground einen Algorithmus der alle Folgenglieder $F_n < 1000$ der Fibonaccifolge
\begin{equation}
F_n = F_{n-1} + F_{n-2}
\end{equation}
\begin{equation}
F_1=1, F_2=2
\end{equation}
in der Konsole ausgibt.

\exchinweis{Versucht's mit einer \swiftinline{while}-Schleife und zwei Variablen für die letzten beiden Folgenglieder, die außerhalb der Schleife definiert wurden. Wer die Aufgabe richtig \emph{swifty} lösen will kann stattdessen ein \swiftinline{struct: FibonacciSequence} schreiben welches das \swiftinline{SequenceType} Protokoll erfüllt.}

\end{excitem*}


\begin{excitem*}{primenumbers}{Primzahlen}{1}

\begin{enumerate}

\item Schreibt eine Funktion \swiftinline{func isPrimeNumber(n: Int) -> Bool} die eine Zahl annimmt und \swiftinline{true} zurückgibt, wenn diese eine Primzahl ist, andernfalls \swiftinline{false}.

\exchinweis{Iteriert in einer \swiftinline{for}-Schleife durch alle Zahlen von 2 bis n: \swiftinline{for i in 2..<n}. Überspringt den Schleifenschritt mit \swiftinline{continue} wenn \swiftinline{i} gleich \swiftinline{n} ist. Prüft sonst mit dem Modulo-Operator \swiftinline{|\%|} den Rest der Division \swiftinline{n |\%| i} der beiden Zahlen. Ist dieser \swiftinline{0} so ist \swiftinline{n} durch \swiftinline{i} teilbar und ihr könnt \swiftinline{false} zurückgeben: \swiftinline{return false}. Gebt sonst nach dem Durchlauf der Schleife \swiftinline{true} zurück.}

\item Schreibt dann eine Funktion \swiftinline{func primeNumbersUpTo(maxNumber: Int) -> [Int]} die alle Primzahlen bis \swiftinline{maxNumber} als Liste \swiftinline{[Int]} (kurz für \swiftinline{Array<Int>}) zurückgibt.

\exchinweis{Erstellt zuerst eine leere Liste von \swiftinline{Int}s: \swiftinline{var primeNumbers: [Int] = []}. Iteriert dann in einer \swiftinline{for}-Schleife durch die Zahlen \swiftinline{1...maxNumber} und fügt die Zahl der Liste mit \swiftinline{primeNumbers.append(n)} hinzu wenn sie \swiftinline{isPrimeNumber(n)} erfüllt. Gebt die Liste mit \swiftinline{return primeNumbers} nach Schleifendurchlauf zurück. Richtig \emph{swifty} könnt ihr die Aufgabe auch in einer Zeile lösen indem ihr die Methode \swiftinline{filter} von \swiftinline{SequenceType} verwendet.}

\end{enumerate}

\end{excitem*}


\begin{excitem}{chatter}{Chatter}{2}

In dieser Aufgabe schreiben wir zusammen an einer App!

Forkt das Repository \url{https://github.com/ios-dev-kurs/chatter} und erstellt eine Pull Request um eure Lösung einzureichen oder Fragen zu stellen.

\begin{enumerate}[label=\roman*.]

\item Die \emph{Chatter} App ist in der \filename{README.md} Datei beschrieben. Ihr könnt euch die Projektdateien anschauen und die App im Simulator oder auf euren Geräten ausführen und ausprobieren. Wenn euch interessiert, wie die App aufgebaut ist, lest die \filename{README.md} und die Kommentare im Code.

\item Ihr habt nun sicherlich erkannt worum es in der App geht: Instanzen verschiedener Subklassen von \swiftinline{Chatter} chatten miteinander. Dabei überschreiben die Subklassen jeweils nur die Implementierung weniger Methoden, die in der \swiftinline{Chatter} Klasse dokumentiert sind.

Eure Aufgabe ist es nun, eine eigene Subklasse zu schreiben und damit euren Beitrag zu dieser App zu leisten! Ihr könnt einen bekannten Charakter darstellen oder einen Neuen erschaffen. Ich übernehme eure Pull-Request dann in das Original-Repository, sodass euer Charakter mit denen aller anderen Kursteilnehmer chatten kann.

Erstellt dazu mit \keys{\cmd + N} eine neue \filename{.swift}-Datei mit dem Namen eures Charakters und platziert sie im Xcode Project Navigator unter \menu{chatter > Model > Chatters}. Orientiert euch an \swiftinline{Yoda.swift} um eure neue Subklasse von \swiftinline{Chatter} zu implementieren.

\item Überschreib die relevanten Methoden in eurer Subklasse wie in der \filename{README.md} Datei beschrieben. Hier könnt ihr einfach zufällige Chatnachrichten generieren, oder auch komplexere Mechaniken einbauen, sodass eine etwas natürlichere Konversation zustande kommt.

In eurer eigenen Subklasse könnt ihr dabei beliebig Code schreiben und bspw. Attribute einführen, um den Zustand eures Charakters darzustellen, wenn ihr möchtet. Er oder sie (oder es?) könnte bspw. mit jeder Nachricht wütender werden oder dergleichen.

\item Sichert eure Änderungen regelmäßig in Commits, wenn der Code fehlerfrei kompiliert. Achtet darauf nur Änderungen eurer Subklasse und nur wenn nötig Änderungen in anderen Dateien zu committen. Die \filename{project.pbxproj} Datei enthält Informationen zu den Projektdateien - da ihr neue Dateien hinzugefügt habt, gehört diese zum Commit dazu.

\item Mit eurem Fork des Repositories auf GitHub könnt ihr eure Änderungen jederzeit abgleichen. Bei der Gelegenheit bietet es sich an auch die neuesten Änderungen aus dem Original-Repository herunterzuladen, sodass ihr die neuen Charaktere der anderen Kursteilnehmer erhaltet:

\begin{shcode}
git pull https://github.com/ios-dev-kurs/chatter.git master
\end{shcode}

Die \shinline{pull} Operation versucht, die heruntergeladenen Änderungen mit den lokalen Änderungen zusammenzuführen. Das klappt nicht immer ohne Konflikte. Da jeder von euch dem Projekt eine Datei hinzufügt ändert sich jeweils die \filename{project.pbxproj} Datei. Treten Konflikte auf, müsst die die Datei in einem Texteditor öffnen und nach den Konfliktmarkierungen suchen:

\begin{shcode}
<<<<<<< HEAD:
# lokaler Code vor dem Merge
=======
# durch den Merge veränderter Code
>>>>>>>
\end{shcode}

Behebt den Konflikt indem ihr die Konfliktmarkierungen löscht und den Code dazwischen gegebenenfalls anpasst. Dann könnt ihr den Merge committen:

\begin{shcode}
git add --all
git commit
\end{shcode}

Euer Repository enthält dann sowohl den aktuellen Stand des Original-Repositories, als auch eure Änderungen.

\item Wenn ihr mit eurer neuen \swiftinline{Chatter} Subklasse zufrieden seid schickt mir eine Pull-Request. So werden eure Änderungen in das Original-Repository integriert und tauchen auch bei den anderen Teilnehmern auf, wenn diese das nächste mal einen \shinline{git pull} durchführen.

Ich bin gespannt auf eure Implementierungen!

\end{enumerate}

\end{excitem}


\begin{excitem}{emails}{Poker}{3}

In dieser Aufgabe berechnen wir die Wahrscheinlichkeit für einen \emph{Flush} beim Poker.

Forkt das Repository \url{https://github.com/ios-dev-kurs/poker} und erstellt eine Pull Request um eure Lösung einzureichen oder Fragen zu stellen.

\begin{enumerate}[label=\roman*.]

\item Zuerst modellieren wir die Spielkarten. Eine Karte \swiftinline{Card} hat immer eine \emph{Farbe} \swiftinline{Suit} (Karo, Herz, Pik oder Kreuz) und einen \emph{Rang} \swiftinline{Rank} (2 bis 10, Bube, Dame, König oder Ass).

Wir modellieren \swiftinline{Card} als Struct, und \swiftinline{Suit} und \swiftinline{Rank} als Enums. Warum verwenden wir keine Klasse für \swiftinline{Card}? Warum eignet sich ein Enum so hervorragend für \swiftinline{Suit} und \swiftinline{Rank}? Beantwortet diese Fragen kurz stichwortartig in einem Kommentar im Playground.

\item Schreibt zwei Enums \swiftinline{enum Suit: Int} und \swiftinline{enum Rank: Int} mit ihren jeweiligen Fällen (\swiftinline{case diamonds} usw.). Bei den Rängen \emph{2} bis \emph{10} schreibt ihr am besten die Zahl aus (\swiftinline{case two} usw.).

Implementiert jeweils eine \emph{Computed Property} \swiftinline{var description: String} in der ihr mithilfe einer \swiftinline{switch}-Abfrage für jeden Fall ein Symbol zurückgebt. \strong{Tipp:} Für Karo, Herz, Pik und Kreuz gibt es Unicode-Symbole\linkref{http://en.wikipedia.org/wiki/Playing_cards_in_Unicode}! Außerdem verlangt das Protokoll \swiftinline{CustomStringConvertible} nur das Attribut \swiftinline{description}, schreibt also z.B. \swiftinline{enum Suit: Int, CustomStringConvertible} damit das Symbol in \swiftinline{print}s verwendet wird.
	
Schreibt dann einen \swiftinline{struct Card} mit zwei Attributen \swiftinline{let suit: Suit} und \swiftinline{let rank: Rank}, sowie einer \emph{Computed Property} \swiftinline{var description: String}, die einen aus Farbe und Rang zusammengesetzten String zurückgibt. Lasst auch \swiftinline{Card} das \swiftinline{CustomStringConvertible} Protokoll erfüllen.
		
\item Nun können wir eine Poker Hand modellieren. Schreibt den \swiftinline{struct PokerHand} mit einem Attribut \swiftinline{let cards: [Card]} und einer \emph{Computed Property} \swiftinline{var description: String}, die die \swiftinline{description} der Karten kombiniert.

Um einfach zufällige Poker Hände generieren zu können, implementiert einen Initializer \swiftinline{init()}, der eine Hand aus fünf zufälligen Karten erstellt. \strong{Wichtig:} Da aus einem Deck von paarweise verschiedenen Karten gezogen wird, darf keine Karte doppelt vorkommen.
	
	\begin{exchinweise}
		\item Da wir \swiftinline{Suit} und \swiftinline{Rank} von \swiftinline{Int} abgeleitet haben, können wir Zufallszahlen generieren und die Enums daraus erstellen:
	
		\begin{swiftcode}
        let rndSuit = Suit(rawValue: Int(arc4random_uniform(4)))!
        let rndRank = Rank(rawValue: Int(arc4random_uniform(13)))!
        let rndCard = Card(suit: rndSuit, rank: rndRank) // Eine zufällige Spielkarte
		\end{swiftcode}
		
		\item Die Funktion \swiftinline{contains} könnte hilfreich sein, um das Vorhandensein von Karten zu überprüfen. Um diese mit \swiftinline{Card} verwenden zu können muss \swiftinline{Card} das \swiftinline{Equatable} Protokoll erfüllen. Schreibt \swiftinline{extenstion Card: Equatable {}} und dann außerhalb:
		
		\begin{swiftcode}
        func ==(lhs: Card, rhs: Card) -> Bool {
            return lhs.suit == rhs.suit && lhs.rank == rhs.rank
        }
		\end{swiftcode}
	\end{exchinweise}
	
Erstellt ein paar Poker Hände und lasst euch die \swiftinline{description} ausgeben. Habt ihr etwas gutes gezogen?

\item Implementiert nun ein weiteres Enum \swiftinline{enum Ranking: Int} mit den Fällen \swiftinline{case highCard, flush, straightFlush} usw., die ihr bspw. auf Wikipedia\linkref{http://en.wikipedia.org/wiki/List_of_poker_hands} findet.

Fügt dann dem \swiftinline{struct PokerHand} eine Computed Property \swiftinline{var ranking: Ranking} hinzu. Implementiert hier einen Algorithmus, der prüft, ob ein \emph{Flush} vorliegt. Dann soll \swiftinline{.flush} zurückgegeben werden, ansonsten einfach \swiftinline{.highCard}.
	
\item Wir können nun einige tausend Hände generieren und die Wahrscheinlichkeit für einen Flush abschätzen. Fügt einfach folgenden Code am Ende des Playgrounds ein:

\begin{swiftcode}
var rankingCounts = [Ranking : Int]()
let samples = 1000
for i in 0...samples {
    let ranking = PokerHand().ranking
    if rankingCounts[ranking] == nil {
        rankingCounts[ranking] = 1
    } else {
        rankingCounts[ranking]! += 1
    }
}

for (ranking, count) in rankingCounts {
    print("The probability of being dealt a \(ranking.description) is \(Double(count) / Double(samples) * 100)%")
}
\end{swiftcode}

Die Ausführung kann etwas dauern, justiert ggfs. \swiftinline{samples}. Stimmt die Wahrscheinlichkeit ungefähr mit der Angabe auf Wikipedia überein?

\item \strong{Extra:} Ihr könnt das Programm nun noch erweitern und versuchen, die anderen Ränge zu überprüfen. Dabei könnten Hilfsattribute wie \swiftinline{var hasFlush: Bool} oder \swiftinline{var pairCount: Int} nützlich sein. Bekommt es jemand es jemand hin, eine Funktion zu schreiben, die zwei Hände vergleicht und den Sieger bestimmt? \strong{Tipp:} Dazu könnte es hilfreich sein, die Fälle des \swiftinline{enum: Ranking} um \emph{Associated Attributes} zu erweitern.

\end{enumerate}

\end{excitem}

\end{exc}


\end{lecture}



\end{document} %%% MARKER %%%



\begin{lecture} % Lecture 5


\chapter{View Hierarchie}

Die iOS App Entwicklung orientiert sich konsequent am \emph{Model-View-Controller Konzept} der Programmierung. Es ist nicht nur in Apples Frameworks wie \swiftinline{UIKit} rigoros umgesetzt sondern stellt auch die Grundlage für die weitere Konzeption unserer Apps dar und wird auch in vielen anderen Bereichen der Softwareentwicklung verwendet. Das Konzept ist im Skript beschrieben und sollte bei Entscheidungen zur Architektur einer App stets als Referenz verwendet werden.

\skriptref{Das Model-View-Controller Konzept}

Wir betrachten nun zunächst die \emph{View} Komponente des Konzepts. Im Skript wird die \swiftinline{UIView} Klasse des \swiftinline{UIKit} Frameworks vorgestellt, die mit ihren Subklassen die Anzeige von Interfaceelementen auf dem Bildschirm übernimmt. Wir werden in diesem Kapitel die \emph{View Hierarchie} kennenlernen, \swiftinline{UIView} Objekte erstellen und anzeigen, sowie mithilfe des \emph{Auto Layout} Konzepts das User Interface dynamisch anpassen.



\section{Handgeschriebene View Hierarchie}

\mvcindicatorview

\skriptref{View Hierarchie}

\begin{enumerate}
\item Ihr könnt das MVC-Konzept noch nicht im Schlaf rezitieren? Unbedingt erstmal im Skript nachlesen!
\item Zuvor haben wir für Xcode Projekte ein Template mit vorkonfiguriertem Target, Storyboard und View Controller verwendet. Für den allgemeinen Gebrauch sind solche Templates sehr sinnvoll, doch nun möchten wir die Architektur einer iOS App einmal genauer untersuchen. Verwendet dafür das \shinline{viewhierarchy_bare} Projekt, das auf der Vorlesungsseite zur Verfügung steht.
\item Das Projekt beinhaltet nur ein Target \shinline{viewhierarchy} und zwei Dateien: eine Konfigurationsdatei \shinline{Info.plist} und eine mit dem \emph{Entry Point} Attribut \swiftinline{@UIApplicationMain} als \emph{Application Delegate} markierte Klasse \swiftinline{AppDelegate}. Im Skript könnt ihr euch über den Startprozess einer iOS App informieren.

Implementieren wir die \swiftinline{application:didFinishLaunchingWithOptions:} Methode des Application Delegates, wird diese am Ende des Startvorgangs aufgerufen:

\begin{swiftcode}
@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?

    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {        
        NSLog("Hello World!")
        return true
    }
}	
\end{swiftcode}

\item Da wir in der \shinline{Info.plist} Datei kein Storyboard angeben, wird beim Start der App einfach ein leeres \swiftinline{UIWindow} erstellt und angezeigt. Das können wir auch selbst tun:

\begin{swiftcode}
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
    let window = UIWindow(frame: UIScreen.mainScreen().bounds)
    window.backgroundColor = UIColor.whiteColor()
    window.makeKeyAndVisible()
    self.window = window
    return true
}
\end{swiftcode}

\item Nun können wir die View Hierarchie des angezeigten \swiftinline{UIWindow} mit weiteren Objekten der Superklasse \swiftinline{UIView} füllen und diese somit auf dem Bildschirm anzeigen:
\begin{swiftcode}
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
    let window = UIWindow(frame: UIScreen.mainScreen().bounds)
    window.backgroundColor = UIColor.whiteColor()
    window.makeKeyAndVisible()
    self.window = window
    
    let label = UILabel(frame: CGRect(x: 0, y: 50, width: window.frame.size.width, height: 50))
    label.text = "Hello World!"
    label.backgroundColor = UIColor.redColor()
    window.addSubview(label)
    
    let button = UIButton(frame: CGRect(x: window.frame.size.width / 2 - 40, y: 120, width: 80, height: 44))
    button.backgroundColor = UIColor.blackColor()
    button.setTitle("Click!", forState: .Normal)
    button.addTarget(self, action: "clickButtonPressed:", forControlEvents: .TouchUpInside) // Diese Methode ist das Äquivalent einer IBAction Verbindung
    window.addSubview(button)
    
    return true
}

func clickButtonPressed(sender: UIButton) {
    println("Click!")
}
\end{swiftcode}

\end{enumerate}

\begin{exc}

\begin{excitem}{view_hierarchy}{Color Match}{2+1}

Verwendet das \shinline{viewhierarchy_bare} Projekt als Ausgangspunkt um (ohne den Interface Builder zu verwenden) eine einfache App zu schreiben. Denkt euch etwas eigenes aus (das kann jedoch schnell komplex werden), oder implementiert das folgende einfache Spiel:

Auf dem Bildschirm werden Buttons angezeigt, die jeweils eine Farbe als Hintergrund und den Namen einer (ggfs. anderen!) Farbe als Titel tragen. Man muss nun versuchen, auf solche Buttons zu tippen, deren Farbe und Titel übereinstimmen.

\strong{Bonus [+1]:} Verwendet dabei Git, um euer Projekt in Form von Commits zu sichern und stellt es zur Abgabe auf GitHub zur Verfügung.

Nach dem MVC-Konzept trennen wir die Implementierung von Modell, Präsentation und Steuerung:

\begin{description}
	\item[Model] Erstellt eine Swift Datei \shinline{ColorWord.swift} und implementiert ein Struct \swiftinline{ColorWord} mit zwei Attributen \swiftinline{color: UIColor} und (Überraschung!) \swiftinline{word: String}. Das Struct benötigt zusätzlich einen Initializer \swiftinline{init()}, der eine zufällige Kombination erstellt, sowie ein Computed Attribute \swiftinline{isCorrect: Bool}, das prüft, ob Farbe und Wort zusammenpassen.
	\item[View] Implementiert eine Subklasse \swiftinline{ColorButton: UIButton} in einer weiteren Swift Datei. Diese benötigt nur eine Methode \swiftinline{configureForColorWord:}, die eine Instanz \swiftinline{colorWord: ColorWord} als Argument annimmt und die \swiftinline{backgroundColor} und \swiftinline{title} Attribute, die von \swiftinline{UIButton} geerbt werden, entsprechend setzt.
	\item[Controller] Der Steuerungscode wird normalerweise in Subklassen von \swiftinline{UIViewController} geschrieben, doch hier verwenden wir einfach die \swiftinline{AppDelegate} Klasse.
	
	Fügt der \swiftinline{AppDelegate} Klasse die Attribute \swiftinline{var score: Int}, \swiftinline{var rounds: Int}, \swiftinline{var timer: NSTimer?}, sowie \swiftinline{var scoreLabel: UILabel!} und \swiftinline{var colorButtons: [ColorButton]} hinzu.
	
	Das Spiel kann nun bspw. so ablaufen:
	
	\begin{enumerate}
		\item In \swiftinline{application:didFinishLaunchingWithOptions:} wird das \swiftinline{window} und das \swiftinline{scoreLabel} erstellt und konfiguriert.
		\item Dann wird (ggfs. mehrmals) eine Methode \swiftinline{addColorButton} aufgerufen, die einen solchen Button erstellt und dem Array \swiftinline{colorButtons} sowie der View Hierarchie hinzufügt. Überlegt euch, wie ihr den Button positioniert. Wenn der Button betätigt wird, soll \swiftinline{colorButtonPressed:} aufgerufen werden.
		\item Die Methode \swiftinline{colorButtonPressed(sender: ColorButton)} muss dann natürlich implementiert werden. Prüft bspw., ob die Kombination des betätigten Buttons korrekt ist, um entsprechend Punkte von \swiftinline{score} abzuziehen oder hinzuzufügen. Anschließend soll eine Methode \swiftinline{prepareNextRound} aufgerufen werden.
		\item \swiftinline{prepareNextRound} fügt zunächst gegebenenfalls weitere Buttons mit \swiftinline{addColorButton} hinzu, um den Schwierigkeitsgrad zu erhöhen. Dann soll jeder angezeigte Button mit einem neuen \swiftinline{ColorWord} konfiguriert werden und ein Timer gestartet werden:
		\begin{swiftcode}
    func prepareNextRound() {
        self.rounds++
        // ...
        if let timer = self.timer {
            timer.invalidate()
        }
        self.timer = NSTimer.scheduledTimerWithTimeInterval(/* Zeit in sec */, target: self, selector: "timerFired:", userInfo: nil, repeats: false)
    }
		\end{swiftcode}
		\item Die Methode \swiftinline{timerFired(timer: NSTimer)} wird nun nach Ablauf des Timers aufgerufen und muss implementiert werden. Hier können bspw. Punkte von der \swiftinline{score} abgezogen werden, wenn ein Button die korrekte Kombination trägt. Anschließend soll wieder \swiftinline{prepareNextRound} aufgerufen werden.
		\item \swiftinline{prepareNextRound} könnt ihr auch am Ende der \swiftinline{application:didFinishLaunchingWithOptions:} Methode bereits aufrufen, um den ersten Timer zu starten.
		\item Das \swiftinline{scoreLabel} muss an entsprechenden Stellen aktualisiert werden, am besten mithilfe einer Methode \swiftinline{updateScoreLabel}.
	\end{enumerate}
	
	Um das Spiel interessant zu gestalten, gibt es natürlich an vielen Stellen noch Erweiterungspotential!

\end{description}

\end{excitem}

\end{exc}


\end{lecture}



\begin{lecture}


\section{Auto Layout}

\mvcindicatorview

Eine View Hierarchie können wir offenbar ebenso im Code schreiben wie im Storyboard konfigurieren. Selbst für ein simples Interface wie im vorherigen Abschnitt implementiert ist jedoch viel Code notwendig, da jeder Parameter als Attribut gesetzt werden muss. Der Interface Builder bietet hier effiziente Möglichkeiten, Benutzeroberflächen ohne Code zu konfigurieren und trotzdem mit dem Code zu verknüpfen.

Eine große Stärke des Interface Builders zeigt sich auch bei der Implementierung von dynamischen Benutzeroberflächen. Um auf Änderungen der Darstellung, wie bspw. Orientierungswechsel von Portrait auf Landscape, zu reagieren, müssten wir extensiv Code schreiben und die Frames der Views unserer View Hierarchie berechnen.

iOS Apps verwenden das \emph{Auto Layout} Konzept von \swiftinline{UIKit}. Anstatt manuell Frames zu berechnen, definieren wir Regeln, die das Layout unserer Views erfüllen soll. Dieses Konzept der \emph{Constraints} ist im Skript detailliert beschrieben. Mit \emph{Size Classes} kann das Interface dann für bestimmte Displaygrößen genauer angepasst werden.

\skriptref{Auto Layout}

\begin{enumerate}

\item Betrachten wir die RGB App als Beispiel für eine der zuvor konfigurierten einfachen Benutzeroberflächen. Ihr könnt auch das Projekt einer anderen App mit vergleichsweise einfachem Interface öffnen. Rotieren wir den Simulator mit \keys{\cmd+\arrowkeyright} oder \keys{\cmd+\arrowkeyleft} in die Landscape Orientierung, werden die Frames der einzelnen Views nicht verändert und die Benutzeroberfläche wird nicht wie gewünscht angezeigt \abbref{img:autolayout_rgb_pre}.

\includegraphicsc[.6\textwidth]{img/autolayout_rgb_pre.png}{img:autolayout_rgb_pre}{In der Landscape Orientierung bleiben die absoluten Frames einfach erhalten.}

\item Um das Problem zu lösen, können wir nach dem Auto Layout Konzept nun Constraints definieren und damit \swiftinline{NSLayoutConstraint} Objekte der Superview hinzufügen. Zur Laufzeit positioniert die Superview ihre Subviews dann automatisch, sodass diese Constraints erfüllt sind. Die einfachste Möglichkeit zur Erstellung von Constraints bietet der Interface Builder.

	Im Storyboard stellen wir zunächst sicher, dass Auto Layout für diese Interface Builder Datei aktiviert ist. Dazu muss die Option \emph{Use Autolayout} im File Inspector markiert sein.

\item Nun können wir Constraints zwischen Interfaceelementen nach unseren Vorstellungen definieren. Dazu verwenden wir die Schaltflächen am rechten unteren Bildschirmrand oder ziehen Verbindungslinien zwischen Objekten bei gehaltener \keys{\ctrl}-Taste. Im Skript sind die Möglichkeiten bei der Erstellung von Constraints beschrieben.

\item In einem eindeutigen Layout werden die Constraints blau markiert. Entsprechen nur die Frames nicht den Constraints, erscheinen diese in gelb und ihr könnt das \emph{Resolve Auto Layout Issues} Menü am unteren rechten Bildschirmrand verwenden, um mit einem Klick auf \emph{Update Frames} alle Views entsprechend ihrer Constraints zu positionieren. Bei einem eindeutigen Layout werden die Frames automatisch angepasst, wenn ihr die Konstanten der Constraints verändert. Sind Constraints rot gefärbt, gibt es Konflikte!

Fügt so lange passende Constraints hinzu, bis das Layout dadurch eindeutig beschrieben wird. \strong{Überlegt euch dabei für jede Subview genau, welche Constraints ihr benötigt, um die vier Parameter \swiftinline{x}, \swiftinline{y}, \swiftinline{width} und \swiftinline{height} von \swiftinline{frame} eindeutig festzulegen.} Beachtet die \emph{Intrinsic Content Size}!

\item Je nach Layout kann es nun sinnvoll sein, die Constraints für bestimmte \emph{Size Classes} anzupassen. Sollen einige Interfaceelemente bspw. auf einem breiteren Display nebeneinander statt untereinander positioniert werden, wählen wir zunächst die \emph{horizontal Regular, vertikal Any} Size Class mithilfe der Schaltfläche am unteren Rand des Editorbereichs.

\item Änderungen, die wir nun am Layout durchführen, betreffen nur die Anzeige in dieser Size Class. Wir können also die Interfaceelemente verschieben und Constraints verändern, bis uns das Layout für breite Displays gefällt.

\item Führt die App nun auf den iPhone und iPad Simulatoren aus und testet euer Layout bei verschiedenen Displaygrößen und -orientierungen.

\end{enumerate}

\begin{exc}

\begin{excitem}{autolayout}{Auto Layout}{3}

Fügt eurer Counter, BMI oder RGB App oder einer vergleichbar einfachen App im Storyboard passende Constraints hinzu, sodass die Benutzeroberfläche sowohl in Portrait und Landscape Orientierung als auch bei verschiedenen Displaygrößen sinnvoll angezeigt wird. Dabei sollte das Layout eurer View Hierarchie eindeutig durch Constraints definiert sein. [1 P.]

Löst dann die folgenden Layouts durch geschickte Definition von Constraints. [2 P.]

\begin{exchinweise}
\item Ihr könnt ein neues Projekt \shinline{AutoLayout} nach dem \emph{Single View} Template erstellen und dem Storyboard einfach für jedes Problem ein \emph{View Controller} Objekt aus der Object Library hinzufügen. Dessen View Hierarchie könnt ihr dann im Storyboard mit Views und Constraints konfigurieren. Mit den Schaltflächen im \emph{Simulated Metrics} Abschnitt des \emph{Attribute Inspectors}, könnt ihr bei ausgewähltem View Controller eine Gerätegröße und -orientierung simulieren.
\item In einigen Situationen kann die Verwendung von unsichtbaren Views als Platzhalter hilfreich sein. Dafür kann das Attribut \objcinline{hidden} verwendet werden, das auch im Interface Builder verfügbar ist.
\end{exchinweise}

\begin{enumerate}

\item Eine \swiftinline{UISegmentedControl} und eine \swiftinline{UIProgressView} sind am oberen Bildschirmrand positioniert, eine \swiftinline{UIView} füllt den verbliebenen Platz.

\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_21.png}
\end{minipage}
\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_22.png}
\end{minipage}

\item Zwei Buttons im Abstand von 20pt sind am oberen Bildschirmrand \strong{zusammen} horizontal zentriert. Ein \swiftinline{UISlider} mit zugehörigem Label und eine füllende View befinden sich darunter. Ändern wir den Text der Label, passt sich das Layout an.

\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_31.png}
\end{minipage}
\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_32.png}
\end{minipage}

\item Zwei Views haben (Platzhalter-) Intrinsic Content Sizes von 300x300pt und 100x100pt. Die größere wird wenn möglich vertikal zentriert, hat jedoch immer einen Abstand von mindestens 20pt zur darunter befindlichen kleineren View. Beide sind horizontal zentriert. Die kleinere View ist außerdem immer mindestens 20pt vom unteren Bildschirmrand entfernt. Wird der verfügbare Platz kleiner, wird die größere View vor der kleineren gestaucht.

\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_11.png}
\end{minipage}
\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_13.png}
\end{minipage}

\item Drei Views füllen jeweils den verfügbaren vertikalen Platz mit einem Abstand von 20pt zur Begrenzung. Horizontal sind sie gleichmäßig verteilt.

\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_02.png}
\end{minipage}
\begin{minipage}{.5\linewidth}
  \centering
  \includegraphics[width=\linewidth, height=\linewidth, keepaspectratio]{img/al_01.png}
\end{minipage}

\end{enumerate}

\end{excitem}

\end{exc}


\end{lecture}


\begin{lecture}


\chapter{Cities}

\mvcindicatorcontroller

iOS Apps bestehen im Allgemeinen nicht nur aus einer, sondern aus einer Vielzahl von untereinander verbundenen Bildschirmansichten. Wir haben gelernt, dass jede Komponente der Benutzeroberfläche letztendlich von einem \swiftinline{UIView} Objekt in der View Hierarchie des übergeordneten \swiftinline{UIWindow} Objekts dargestellt wird.

Nun können wir die View Hierarchie einer komplexen App natürlich nicht wie im vorherigen Abschnitt zentral im App Delegate verwalten \excref{exc:view_hierarchy}. Um eine sinnvolle Struktur zu schaffen, implementieren wir stattdessen \emph{View Controller}.

Diese sind der Controller-Komponente des Model-View-Controller Konzepts zugeordnet und im Skript ausführlich beschrieben.

Mit dieser App lernen wir das \emph{View Controller Containment} Prinzip kennen, schreiben eigene \swiftinline{UIViewController} Subklassen und verwenden einige wichtige View Controller aus dem UIKit Framework.

\skriptref{View Controller Hierarchie}

\section{One City}\label{sec:one_city}

Wir wollen zunächst einen Buttons mit dem Titel einer Stadt implementieren und Informationen über die entsprechende Stadt in einem separaten View Controller anzeigen, wenn der Benutzer auf den Button drückt.

\begin{enumerate}

\item Beginnen wir mit einem neuen Xcode Projekt nach dem \emph{Single View} Template und mit dem Product Name \emph{Cities}. Es wird damit automatisch eine Klasse \swiftinline{AppDelegate} und ein Storyboard hinzugefügt. Zusätzlich befindet sich bereits eine Subklasse \swiftinline{ViewController: UIViewController} in unserem Projekt.

\item Die Klasse \swiftinline{ViewController} benennen wir zunächst in \swiftinline{CitiesViewController} um. Dazu muss sowohl die Swift-Datei in \filename{CitiesViewController.swift} als auch der Klassenname in \swiftinline{CitiesViewController: UIViewController} umbenannt werden. Außerdem muss die Klasse im Storyboard angepasst werden (s.u.).

\item Im Storyboard finden wir eine Scene mit einem View Controller. Wie im Skript beschrieben, können wir die zu verwendende \swiftinline{UIViewController} Subklasse im Identity Inspector (\keys{\cmd+\Alt+3}) einstellen. Gebt hier bei ausgewähltem View Controller unter \menu{Custom Class > Class} den Namen \str{CitiesViewController} ein.

Zur Laufzeit wird also ein Objekt dieser Subklasse erzeugt und dem \swiftinline{UIWindow} Objekt als Root View Controller zugeordnet, da die Scene als \emph{Initial Scene} gekennzeichnet ist. Damit wird die Content View dieses View Controllers zu Beginn der Ausführung der App der View Hierarchie des \swiftinline{UIWindow} Objekts hinzugefügt.

\item Ziehen wir nun \swiftinline{UIView} Objekte auf die Content View des View Controllers, werden diese zur View Hierarchie der Content View hinzugefügt. Der View Controller ist für die Verwaltung seiner Content View zuständig. Daher stellen wir Verbindungen in Form von IBOutlets und IBActions her, um Zugriff auf die Objekte zu erhalten und um auf Benutzereingaben reagieren zu können.

Wir benötigen zunächst nur ein \swiftinline{UIButton} Objekt mit entsprechendem IBOutlet, das den Namen einer beliebigen Stadt anzeigen soll \abbref{img:one_city_ui}. Als Titel des Buttons könnt ihr auch zunächst generisch \str{City name} o.ä. wählen, da wir diesen im Code anpassen.

\includegraphicsc[\iphonewidth]{img/one_city_ui.png}{img:one_city_ui}{Ein Button soll bei Betätigung Informationen über die entsprechende Stadt anzeigen}

\item Obwohl wir uns in dieser App hauptsächlich mit der Controller-Komponente beschäftigen, sollten wir eine einfache Datenstruktur implementieren, die zu unserer App passt. So können wir Daten einfacher verarbeiten und weitergeben. Erstellt also in einer neuen Swift Datei ein \swiftinline{struct City} und definiert die Attribute \swiftinline{let name: String} und \swiftinline{let image: UIImage?}.

\begin{swiftcode}
// City.swift
import UIKit

struct City {
    let name: String
    let image: UIImage?
}
\end{swiftcode}

\item Später wird der Cities View Controller eine Liste von Städten anzeigen, doch zunächst beschränken wir uns auf eine einzelne. Fügt \swiftinline{CitiesViewController} daher ein Attribut \swiftinline{var city: City?} hinzu:

\begin{swiftcode}
// CitiesViewController.h
import UIKit

class CitiesViewController: UIViewController {
    var city: City?
    @IBOutlet var cityButton: UIButton!
}
\end{swiftcode}

\item Wir verwenden nun das App Delegate, um zu Beginn der Ausführung der App das Model, also die \swiftinline{City} Objekte, aufzusetzen und an die View Controller Hierarchie weiterzugeben. Implementiert daher folgende \swiftinline{application:didFinishLaunchingWithOptions:} Methode.

\begin{swiftcode}
// AppDelegate.swift
import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?
    
    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
        let melbourne = City(name: "Melbourne", image: UIImage(named: "melbourne"))
        if let citiesViewController = window?.rootViewController as? CitiesViewController {
            citiesViewController.city = melbourne
        }
        return true
    }
}

\end{swiftcode}

Es gibt natürlich auch Städte in Mittelerde, Panem und auf Naboo…

\strong{Hinweis:} Der Initializer \swiftinline{init(named: String)} von \swiftinline{UIImage} lädt die Bilddatei mit dem angegebenen Dateinamen, sofern die Datei im Target referenziert ist. Um dem Target eine Bilddatei hinzuzufügen, könnt ihr sie einfach auf die Dateiliste des Project Navigators ziehen. Praktischer und ressourcenschonender ist jedoch die Verwendung von \emph{Xcode Asset Catalogs} für die Bilddateien einer App. Eine solche mit Dateiendung \filename{.xcassets} ist bereits im Projekt enthalten. Diese Datei könnt ihr öffnen und auf den Bereich links im Editor per \emph{Drag \& Drop} einfach Bilddateien hinzufügen.

\item Im Cities View Controller überschreiben wir die \swiftinline{viewWillAppear:} Methode, um das Interface entsprechend des \swiftinline{City} Objekts zu konfigurieren.

\begin{swiftcode}
// CitiesViewController.swift
import UIKit

class CitiesViewController: UIViewController {
    var city: City?
    @IBOutlet var cityButton: UIButton!
    
    override func viewWillAppear(animated: Bool) {
        cityButton.setTitle(city?.name, forState: .Normal)
    }
}

\end{swiftcode}

Führt ihr die App an dieser Stelle mit einem \emph{Build \& Run} aus, wird der Button mit dem Namen der Stadt konfiguriert und angezeigt.

\item Um nun auf Knopfdruck einen Bildschirm zu präsentieren, der die Informationen der ausgewählten Stadt anzeigt, implementieren wir eine weitere Subklasse von \swiftinline{UIViewController}. Erstellt also eine neue Klasse \swiftinline{CityDetailViewController: UIViewController}. Dieser Klasse übergeben wir das ausgewählte \swiftinline{City} Objekt und überlassen ihr die Konfiguration ihrer Content View entsprechend den Attributen des Objekts. Definiert also wieder ein Attribut \swiftinline{var city: City?} im Header der \swiftinline{CityDetailViewController} Klasse.

\begin{swiftcode}
// CityDetailViewController.h
import UIKit

class CityDetailViewController: UIViewController {
    var city: City?
}
\end{swiftcode}

\item Nun verwenden wir das Storyboard, um die Benutzerführung zu konfigurieren. Zieht ein View Controller Objekt aus der Object Library auf das Storyboard und platziert es neben dem Cities View Controller. Wählt im Identity Inspector des hinzugefügten View Controllers wie zuvor das Eingabefeld \emph{Class} und gebt den Namen der neuen \swiftinline{UIViewController} Subklasse \str{CityDetailViewController} ein.

\item Platziert ein \swiftinline{UILabel} und ein \swiftinline{UIImageView} Objekt in der Content View des \swiftinline{CityDetailViewController} und verbindet sie mit IBOutlets im Code \abbref{img:city_detail_ui}. Fügt außerdem einen \str{Zurück} Button hinzu.

\includegraphicsc[\iphonewidth]{img/city_detail_ui.png}{img:city_detail_ui}{Der City Detail View Controller soll Information über die ausgewählte Stadt anzeigen}

\begin{swiftcode}
// CityDetailViewController.swift
import UIKit

class CityDetailViewController: UIViewController {
    var city: City?

    @IBOutlet weak var nameLabel: UILabel!
    @IBOutlet weak var imageView: UIImageView!
}
\end{swiftcode}

\item Zur Präsentation des City Detail View Controllers können wir nun \emph{Segues} verwenden. Diese repräsentieren, wie im Skript beschrieben, Beziehungen zwischen einzelnen Scenes im Storyboard. Segues können analog zu IBOutlets und IBActions erstellt werden, indem eine Verbindungslinie mit gedrückter \keys{\ctrl}-Taste gezogen wird. Wählt den Button im Cities View Controller aus und zieht eine Verbindung zum City Detail View Controller \abbref{img:one_city_detail_segue}. Erstellt so eine \emph{Modal Segue} zwischen Button und View Controller (die Auswahlmöglichkeiten \emph{show}, \emph{show detail} und \emph{present modally} haben in diesem Fall die gleiche Wirkung). 

\includegraphicsc{img/one_city_detail_segue.png}{img:one_city_detail_segue}{Eine Modal Segue konfiguriert die Präsentation des City Detail View Controllers bei Betätigung des Buttons}

Im Attributes Inspector könnt ihr die Segue konfigurieren und bspw. zwischen verschiedenen Übergangsanimationen auswählen. Hier kann außerdem ein \emph{Identifier} für die Segue vergeben werden. Setzt diesen auf \str{showCityDetail}.

\item Dem erstellten City Detail View Controller muss vor der Präsentation ein \swiftinline{City} Objekt übergeben werden, damit er dessen Attribute darstellen kann. Dazu implementieren wir die Instanzmethode \swiftinline{prepareForSegue:sender:} in unserer \swiftinline{CitiesViewController} Klasse.

\begin{swiftcode}
// CitiesViewController.swift
import UIKit

class CitiesViewController: UIViewController {
    // ...    
    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        if let identifier = segue.identifier {
            switch identifier {
            case "showCityDetail":
                if let cityDetailViewController = segue.destinationViewController as? CityDetailViewController {
                    cityDetailViewController.city = self.city
                }
            default:
                break
            }
        }
    }
}
\end{swiftcode}

Hier geben wir das \swiftinline{City} Objekt also einfach an den City Detail View Controller weiter.

\item Schließlich müssen wir den City Detail View Controller für die Darstellung der Attribute des \swiftinline{City} Objekts konfigurieren. Dies geschieht am besten in einer Implementierung der \swiftinline{viewWillAppear:} Instanzmethode in der \swiftinline{CityDetailViewController} Klasse.

\begin{swiftcode}
// CityDetailViewController.swift
import UIKit

class CityDetailViewController: UIViewController {
    var city: City?

    @IBOutlet weak var nameLabel: UILabel!
    @IBOutlet weak var imageView: UIImageView!
    
    override func viewWillAppear(animated: Bool) {
        self.nameLabel.text = city?.name
        self.imageView.image = city?.image
    }
}
\end{swiftcode}

Betätigt ihr nun nach einem \emph{Build \& Run} den Button, wird die Content View des City Detail View Controller angezeigt und mit dem entsprechenden \swiftinline{City} Objekt konfiguriert \abbref{img:one_city_run}.

\includegraphicsc[\iphonewidth]{img/one_city_run.png}{img:one_city_run}{Wird der Button betätigt, zeigt der City Detail View Controller die Informationen zu der ausgewählten Stadt}

\item Nun fehlt nur noch die Implementierung des \emph{Zurück} Buttons. Hier verwenden wir das Konzept der \emph{Unwind Segue}, um zu einem View Controller in der View Controller Hierarchie zurückzukehren. Dazu fügen wir dem \strong{präsentierenden} View Controller (nicht dem präsentierten) eine Methode \swiftinline{unwindToCities:} nach dem im Skript beschriebenen Muster hinzu, sodass sie im Interface Builder zur Verfügung steht.

\begin{swiftcode}
// CitiesViewController.swift
import UIKit

class CitiesViewController: UIViewController {
    // ...
    @IBAction func unwindToCities(segue: UIStoryboardSegue) {
        // no implementation necessary
    }
}
\end{swiftcode}

\item Im Storyboard können wir nun das \swiftinline{UIControlEvent.TouchUpInside} Event des \emph{Zurück} Buttons mit der Unwind Segue verbinden. Zieht dazu bei gehaltener \keys{\ctrl}-Taste eine Verbindung vom Button zur \emph{Exit} Schaltfläche des City Detail View Controllers (also des \strong{präsentierten} View Controllers) \abbref{img:cities_unwind_segue}. Da ein View Controller in der View Controller Hierarchie eine Unwind Segue \swiftinline{unwindToCities:} implementiert, könnt ihr diese hier auswählen.

\includegraphicsc[\iphonewidth]{img/cities_unwind_segue.png}{img:cities_unwind_segue}{Die \emph{Exit} Schaltfläche präsentiert alle Unwind Segues in der View Controller Hierarchie}

Führt ihr die App nun aus und betätigt den \emph{Zurück} Button, so wird die Unwind Segue zum Cities View Controller ausgeführt und damit der City Detail View Controller wieder ausgeblendet.

\end{enumerate}

\begin{exc}
\begin{excitem}{cities}{Cities}{2+1}

Implementiert diesen ersten Teil der Cities App, indem ihr die Schritte oben nachvollzieht.

\strong{Bonus [+1]:} Sichert das Projekt regelmäßig durch Commits in einem Git Repository und stellt es auf GitHub zur Verfügung.

\end{excitem}
\end{exc}


\end{lecture}



\begin{lecture}


\section{One City Navigation}

Eine solche Master-Detail View Controller Hierarchie, wie wir sie in \autoref{sec:one_city} implementiert haben, ist ein so häufig verwendetes Konzept, dass \swiftinline{UIKit} dafür die Subklasse \objcinline{UINavigationController: UIViewController} zur Verfügung stellt. Diese wird im Skript erläutert und eignet sich an dieser Stelle besser als Modal Segues.

\begin{enumerate}

\item Zieht einfach ein \swiftinline{UINavigationController} Objekt aus der Object Library auf euer Storyboard. Dabei wird zusätzlich zu der Navigation Controller Scene automatisch eine weitere View Controller Scene als Root View Controller des Navigation Controllers hinzugefügt. Löscht diesen zusätzlichen View Controller und wählt stattdessen den \swiftinline{CitiesViewController} als Root View Controller. Erstellt dafür eine \emph{Relationship Segue} zwischen beiden Objekten, indem ihr wieder mit gedrückter \keys{\ctrl}-Taste eine Verbindung zieht. Markiert außerdem den Navigation Controller als Initial View Controller \abbref{img:nav_controller_segue}.

\includegraphicsc{img/nav_controller_segue.png}{img:nav_controller_segue}{Eine Relationship Segue markiert den Root View Controller eines Navigation Controllers}

\item Ihr könnt nun die Segue zwischen \swiftinline{CitiesViewController} und \swiftinline{CityDetailViewController} auswählen und im Attributes Inspector sicherstellen, dass der Typ \emph{Show} ausgewählt ist. Wenn die Segue ausgelöst wird fängt dann der in der View Controller Hierarchie übergeordnete \swiftinline{UINavigationController} die Präsentation des \swiftinline{CityDetailViewController} ab.

\item Den \emph{Zurück} Button könnt ihr nun entfernen, da \swiftinline{UINavigationController} einen eigenen Mechanismus implementiert und eine \swiftinline{UINavigationBar} am oberen Bildschirmrand anzeigt. Auch die Labels werden nicht mehr benötigt. Stattdessen können wir das \swiftinline{title: String} Attribut von \swiftinline{UIViewController} verwenden, dessen Wert als Titel in der Navigation Bar angezeigt wird \abbref{img:nav_controller_ui}.

\includegraphicsc{img/nav_controller_ui.png}{img:nav_controller_ui}{Navigation Controller zeigen eine Navigation Bar an}

\begin{swiftcode}
// CityDetailViewController.swift
import UIKit

class CityDetailViewController: UIViewController {
    var city: City?

    @IBOutlet weak var imageView: UIImageView!
    
    override func viewWillAppear(animated: Bool) {
        self.title = city?.name
        self.imageView.image = city?.image
    }
}
\end{swiftcode}

\item Da wir den Initial View Controller und damit den Root View Controller des Window Objekts verändert haben, müssen wir noch kurz die Implementierung des App Delegates anpassen, um das City Objekt korrekt weiterzugeben:

\begin{swiftcode}
// AppDelegate.swift > application:didFinishLaunchingWithOptions:
let melbourne = City(name: "Melbourne", image: UIImage(named: "melbourne"))
if let citiesViewController = (window?.rootViewController as? UINavigationController)?.topViewController as? CitiesViewController {
    citiesViewController.city = melbourne
}
\end{swiftcode}

\item Durch die Verwendung des Navigation Controllers erhält unsere App nun die Standardanimationen und -mechanismen aus \swiftinline{UIKit} \abbref{img:nav_controller_run}, die sich bspw. durch die Verwendung von Subklassen und Implementierung von Delegate-Protokollen vielseitig anpassen lassen. \\
	\swiftinline{UIKit} stellt noch weitere View Controller Container wie \swiftinline{UITabBarController} und \swiftinline{UISplitViewController} zur Verfügung, die nach einem ähnlichen Prinzip funktionieren, sowie eine vielseitige API zur Implementierung eigener View Controller Container.

\includegraphicsc[\iphonewidth]{img/nav_controller_run.png}{img:nav_controller_run}{Navigation Controller stellen Standardanimationen und -mechanismen zur Verfügung}

\end{enumerate}


\section{More Cities}

Wenn wir eine Liste von Objekten darstellen wollen, konfigurieren wir natürlich nicht explizit Views für jedes Objekt. Stattdessen verwenden wir Subklassen von \swiftinline{UITableViewController: UIViewController} und ihre Content Views der Klasse \swiftinline{UITableView: UIView}, die mit dem \emph{Delegate Konzept} vielseitig einsetzbar sind.

\skriptref{Das Delegate Konzept, Table Views \& Table View Controller}

\begin{enumerate}

\item Wir möchten nun eine Liste von Städten anstatt einzelner Buttons anzeigen. Dafür ändern wir die Superklasse unseres \swiftinline{CitiesViewController} von \swiftinline{UIViewController} zu \swiftinline{UITableViewController}. Außerdem können wir die IBOutlet Referenz zu dem \emph{cityButton} entfernen.

\item Ein Table View Controller hat ein Objekt der \swiftinline{UITableView} Klasse als Content View. Im Storyboard müssen wir daher die bisherige Content View mit einem Table View Objekt aus der Object Library ersetzen. Die Content View wird ersetzt, wenn wir die neue View einfach auf das View Controller Objekt in der Document Outline links ziehen.

\strong{Hinweis:} Anstatt einen existierenden View Controller wie beschrieben in einen Table View Controller umzukonfigurieren, kann auch ein Table View Controller aus der Object Library gezogen werden. Dieser hat dann bereits eine \swiftinline{UITableView} als Content View.

\item Eine Table View kann, wie im Skript beschrieben, dynamischen oder statischen Inhalt darstellen. Im Attributes Inspector können wir den Modus \emph{Dynamic Properties} auswählen. Damit die Table View nun Inhalt präsentieren kann, benötigt sie \emph{Prototype Cells}, die den "{}Bauplan"{} für jede Zelle dieser Art definieren. Fügt dafür eine \swiftinline{UITableViewCell} aus der Object Library hinzu oder erhöht die entsprechende Zahl im Attributes Inspector um 1.

\item Wir können Prototype Cells nun entweder nach Belieben mit Subviews konfigurieren, oder im Attributes Inspector einen Standardstil auswählen. Wählt hier zunächst einfach \emph{Basic} \abbref{img:morecities_prototypecells}.

\includegraphicsc[\iphonewidth]{img/morecities_prototypecells.png}{img:morecities_prototypecells}{Prototype Cells dienen als Vorlage für die Zellen der Table View}

\item Um Prototype Cells zu identifizieren, sollte ihnen ein \emph{Reuse Identifier} im Attributes Inspector zugeordnet werden. Tippt hier \str{cityCell} ein. Wie im Skript erklärt kann die Table View damit Zellen, die gerade nicht angezeigt werden, an anderer Stelle wiederverwenden.

\item Da unsere Table View dynamischen Inhalt anzeigen soll, können wir diesen nicht im Storyboard konfigurieren. Stattdessen verwendet die Table View das \emph{Delegate Kozept}, um Daten zu "{}erfragen"{}, wenn sie sie benötigt. Dazu ruft das \swiftinline{UITableView} Objekt Methoden auf einem Delegate Objekt auf, die in einem \emph{Protokoll} definiert sind. \swiftinline{UITableView} teilt diese Anfragen in die \swiftinline{UITableViewDatasource} und \swiftinline{UITableViewDelegate} Protokolle auf. Um den entsprechenden Attributen \swiftinline{datasource: UITableViewDatasource} und \objcinline{delegate: UITableViewDelegate} Objekte zuzuweisen, sind diese als IBOutlets markiert. Zieht also zwei Verbindungen von der Table View zum \swiftinline{CitiesViewController} und wählt diesen damit sowohl als Delegate als auch als Datasource.

\item Häufig repräsentiert eine Table View ein Array, wie hier eine Liste von Städten. Definiert also im öffentlichen Interface des \swiftinline{CitiesViewController} ein Attribut \swiftinline{cities: [City]?} anstatt des bisherigen \swiftinline{city: City?} Attributs.

Passt außerdem erneut die Implementierung des App Delegates an, um diesem Attribut nun eine Liste von Städten zuzuweisen:

\begin{swiftcode}
// AppDelegate.swift
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
    let melbourne = City(name: "Melbourne", image: UIImage(named: "melbourne"))
    let sydney = City(name: "Sydney", image: UIImage(named: "sydney"))
    if let citiesViewController = (window?.rootViewController as? UINavigationController)?.topViewController as? CitiesViewController {
        citiesViewController.cities = [ melbourne, sydney ]
    }
    return true
}
\end{swiftcode}

\item Als Subklasse von \swiftinline{UITableViewController} erbt \swiftinline{CitiesViewController} leere Implementierungen der \swiftinline{UITableViewDatasource} und \swiftinline{UITableViewDelegate} Protokolle. Wir können diese nun überschreiben, um unsere Tabelle mit Daten zu füllen. Dabei sind zunächst die drei erforderlichen Methoden zur Darstellung einer dynamischen Table View zu implementieren:

\begin{swiftcode}
// ViewController.swift
import UIKit

class CitiesViewController: UITableViewController {
    var cities: [City]?
    
    override func numberOfSectionsInTableView(tableView: UITableView) -> Int {
        return 1
    }
    override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return cities?.count ?? 0
    }
    override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
        let city = cities![indexPath.row]
        let cell = tableView.dequeueReusableCellWithIdentifier("cityCell", forIndexPath: indexPath) as! UITableViewCell
        cell.textLabel?.text = city.name
        cell.imageView?.image = city.image
        return cell
    }
    
    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        if let indexPath = self.tableView.indexPathForSelectedRow() {
            let city = cities![indexPath.row]
            if let identifier = segue.identifier {
                switch identifier {
                case "showCityDetail":
                    if let cityDetailViewController = segue.destinationViewController as? CityDetailViewController {
                        cityDetailViewController.city = city
                    }
                default:
                    break
                }
            }
        }
    }
}
\end{swiftcode}

\item Diese drei Methoden des \swiftinline{UITableViewDatasource} Protokolls stellen der Table View die erforderlichen Informationen zur Verfügung, um die Tabelle anzeigen zu können \abbref{img:cities_tableview}.

\includegraphicsc[\iphonewidth]{img/cities_tableview.png}{img:cities_tableview}{Eine Table View stellt Anfragen an ihr Datasource und Delegate Objekt, um Zellen dynamisch anzuzeigen}

\item Die Präsentation des Detail City View Controllers kann nun erneut mithilfe von Segues realisiert werden. Dazu können wir im Storyboard eine Show Segue von der Prototype Cell zum Detail City View Controller erstellen und ihr erneut den Identifier \str{showCityDetail} geben.

\item Da diese Segue nun von jeder Zelle ausgelöst wird, die nach Vorlage der Prototype Cell erstellt wurde, müssen wir in der \swiftinline{prepareForSegue:sender:} Methode wie im Codebeispiel oben zunächst den Index Path der betätigten Zelle herausfinden. Damit lässt sich anschließend das entsprechende Model Objekt erhalten und der City Detail View Controller konfigurieren.

\item Wird nun eine Stadt in der Liste ausgewählt, wird der City Detail View Controller entsprechend konfiguriert und angezeigt. Beachtet, dass wir an dessen Implementierung nichts geändert haben!

\end{enumerate}

\begin{exc}

\begin{excitem}{tableviews}{More Cities}{2}

Implementiert die Cities App nun vollständig, indem ihr die Schritte oben nachvollzieht.

\end{excitem}

\end{exc}


\end{lecture}



\begin{lecture}


\chapter{Seasonizer}

Mit den Apps der vergangenen Vorlesungen haben wir die Grundlagen der Programmierung für iOS Geräte und einige wichtige Architekturkonzepte kennengelernt. Mit diesem Wissen lässt sich bereits ein Großteil der zur Verfügung stehenden Frameworks anwenden und viele Funktionen, die iOS Geräte bieten, in unsere eigenen Apps integrieren.

%Aus gegebenem Anlass implementieren wir in dieser App einige häufig verwendete Funktionen wie Multi-Touch Gesten und Kamera Integration, um beim nächsten Familienfest nicht nur mit unseren neu erworbenen Programmierfähigkeiten anzugeben, sondern auch noch Fotos von Familienmitgliedern festlich dekorieren zu können \abbref{img:seasonizer}.

Zusammenfassend implementieren wir in dieser App einige häufig verwendete Funktionen wie Multi-Touch Gesten und Kamera Integration, um beim nächsten Familienurlaub nicht nur mit unseren neu erworbenen Programmierfähigkeiten anzugeben, sondern auch noch Fotos von Familienmitgliedern sommerlich dekorieren zu können \abbref{img:seasonizer}.

\includegraphicsc[\iphonewidth]{img/seasonizer_summer.png}{img:seasonizer}{Mit der Seasonizer App lassen sich Freunde und Familienmitglieder sommerlich dekorieren.}

\subsubsection{Funktionen der Seasonizer App [4++~P.]}

\begin{itemize}
	\item Die App besitzt eine Hauptansicht mit Navigation Bar und Toolbar. Den Inhalt füllt eine Image View für das Foto und eine darüberliegende View mit transparentem Hintergrund für die Accessories. [1~P.]
	\item Es gibt einen Button in der Toolbar, mit dem ein Foto von der Kamera oder Foto Bibliothek ausgewählt werden kann, das anschließend von der Image View angezeigt wird. [1~P.]
	\item Ein weiterer Button zeigt modal eine Liste von Accessories an. Wird ein Accessory ausgewählt, wird es der Hauptansicht hinzugefügt. [1~P.]
	\item Die Accessories lassen sich mit Gesten verschieben, skalieren, drehen und löschen. [1~P.]
	\item Mit einem Action Button kann das Bild über verschiedene Kanäle wie Nachrichten, Email oder Facebook verteilt werden. [1~P.]
	\item Die Elemente wie Bild und Accessories werden gespeichert und beim nächsten Start der App wiederhergestellt. [1~P.]
	\item Ein Toolbar Button dient dem Zurücksetzen der Benutzeroberfläche. [1~P.]
	%\item [extra] Es schneit in der App!
	\item Implementiert, was euch einfällt! Ich bin auf eure Ideen gespannt. [++~P.]
\end{itemize}

Anders als für die bisherigen Apps wird es an dieser Stelle keine vollständige Schritt-für-Schritt Anleitung geben. Versucht stattdessen, die Funktionen der App zu implementieren, indem ihr die folgenden Hinweise und die Informationen der bisherigen Themen anwendet. Ich stehe dabei natürlich jederzeit gerne für Fragen zur Verfügung.

\subsubsection{Hinweise}

\begin{itemize}

\item Wenn ihr mit dem \emph{Single View} Template beginnt, bietet es sich an, dem View Controller der Hauptansicht zunächst einen sinnvollen Namen wie \swiftinline{CanvasViewController} zu geben. Verwendet außerdem den Project Name \str{Seasonizer}.

\item \strong{Navigation Bar und Toolbar} lassen sich sehr einfach anzeigen, wenn ein Navigation Controller verwendet wird. Dieser besitzt ein Attribut \emph{Shows Toolbar}, das im Interface Builder aktiviert werden kann. Buttons lassen sich dann als Objekte der \swiftinline{UIBarButtonItem} Klasse aus der Object Library einem Navigation Item hinzufügen. \swiftinline{UIBarButtonItem} bietet bereits viele Stile wie \swiftinline{UIBarButtonSystemItemCamera} zur Auswahl im Attributes Inspector an.

\item Die Auswahl zwischen \strong{Kamera und Foto Bibliothek} lässt sich sinnvoll mit einem \swiftinline{UIAlertController} implementieren. Den Zugriff auf Kamera oder Foto Bibliothek übernimmt dann ein entsprechend konfigurierter \swiftinline{UIImagePickerController} aus \swiftinline{UIKit}.

\begin{swiftcode}
    @IBAction func cameraButtonPressed(sender: AnyObject) {
        let alertController = UIAlertController(title: nil, message: nil, preferredStyle: .ActionSheet)
        if UIImagePickerController.isSourceTypeAvailable(.Camera) {
            alertController.addAction(UIAlertAction(title: "Take Photo", style: .Default, handler: { action in
                self.presentImagePickerWithSourceType(.Camera)
            }))
        }
        if UIImagePickerController.isSourceTypeAvailable(.PhotoLibrary) {
            alertController.addAction(UIAlertAction(title: "Choose from Photo Library", style: .Default, handler: { action in
                self.presentImagePickerWithSourceType(.PhotoLibrary)
            }))
        }
        alertController.addAction(UIAlertAction(title: "Cancel", style: .Cancel, handler: nil))
        self.presentViewController(alertController, animated: true, completion: nil)
    }
    func presentImagePickerWithSourceType(sourceType: UIImagePickerControllerSourceType) {
        let imagePicker = UIImagePickerController()
        imagePicker.sourceType = sourceType
        imagePicker.delegate = self
        self.presentViewController(imagePicker, animated: true, completion: nil)
    }
\end{swiftcode}

\item Der \swiftinline{UIImagePickerController} verwendet das Delegate Konzept um die Auswahl eines Fotos zu kommunizieren. Wir setzen den View Controller selbst als Delegate, also muss dieser das \swiftinline{UIImagePickerControllerDelegate} implementieren:

\begin{swiftcode}
class CanvasViewController: UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
    // ...
    func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [NSObject : AnyObject]) {
        self.photoImageView.image = info[UIImagePickerControllerOriginalImage] as? UIImage
        picker.dismissViewControllerAnimated(true, completion: nil)
    }
    func imagePickerControllerDidCancel(picker: UIImagePickerController) {
        picker.dismissViewControllerAnimated(true, completion: nil)
    }
\end{swiftcode}

\item Wir modellieren die Accessories in dieser App als \swiftinline{struct Accessory}. Accessories besitzen jeweils ein Bild einen Titel. Erstellt eine Liste von Accessories im App Delegate und gebt diese Liste durch die View Controller Hierarchie weiter an den \swiftinline{CanvasViewController}.

\item Um modal einen weiteren View Controller mit Titelleiste für die \strong{Accessory Liste} anzuzeigen, kann dieser wiederum in einem Navigation Controller verpackt werden \abbref{img:seasonizer_ui}. Es sollte eine dynamische Table View in einer Subklasse \swiftinline{AccessoryListViewController: UITableViewController} verwendet werden, um die Liste der verfügbaren Accessories anzuzeigen.

\includegraphicsc{img/seasonizer_ui.png}{img:seasonizer_ui}{Navigation Controller bieten eine einfache Möglichkeit, Navigationsleisten und Toolbars anzuzeigen}

\item Der \swiftinline{AccessoryListViewController} benötigt eine Liste von Accessories, die er präsentieren soll, sowie eine Möglichkeit, das ausgewählte Accessory wiederum dem präsentierenden View Controller zu kommunizieren. Dazu könnt ihr entweder ein eigenes Delegate Protokoll implementieren, oder Unwind Segues verwenden. Im Skript findet ihr ein Beispiel für die Implementierung eines Delegate Protokolls. Wenn ihr lieber Unwind Segues verwenden möchtet, müsst ihr die Liste von Accessories zunächst in der \swiftinline{prepareForSegue:} Methode weitergeben und dann das ausgewählt Accessory in der Unwind Methode, bspw. \swiftinline{unwindToCanvas:}, auslesen.

\item Wenn der \swiftinline{CanvasViewController} nun ein \swiftinline{Accessory} bekommt, soll es durch eine View repräsentiert werden, die auf einer transparenten View \swiftinline{accessoryOverlayView} über dem Bild angezeigt wird. Erstellt dafür zunächst eine Subklasse \swiftinline{AccessoryView: UIImageView}:
\begin{swiftcode}
// AccessoryView.swift
import UIKit

class AccessoryView: UIImageView {    
    init(accessory: Accessory) {
        super.init(image: accessory.image)
    }
    required init(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}	
\end{swiftcode}

	Diese könnt ihr dann verwenden, um eine Repräsentation des ausgewählten Accessory zu erstellen:
\begin{swiftcode}
        let accessoryView = AccessoryView(accessory: accessory)
        accessoryView.center = accessoryOverlayView.convertPoint(accessoryOverlayView.center, fromView: accessoryOverlayView.superview)
        self.addAccessoryView(accessoryView) // muss noch implementiert werden
\end{swiftcode}

\item Den Code zum Hinzufügen der Accessory View zur View Hierarchie lagern wir in eine Methode \swiftinline{addAccessoryView:} aus, in der wir die View zunächst konfigurieren können.

Für die Manipulation der Accessories mit Gesten können wir \strong{Gesture Recognizer} verwenden. UIKit implementiert einige hilfreiche Subklassen von \swiftinline{UIGestureRecognizer}, die bestimmt Multi-Touch Events auf der ihr zugewiesenen View erkennen und ihr Delegate Objekt darüber informieren. Also können wir den Canvas View Controller als Empfänger des \swiftinline{UIGestureRecognizerDelegate} Protokolls markieren, Gesture Recognizer in der \swiftinline{addAccessory:} Methode hinzufügen und die Delegate Methoden zum Bewegen, Skalieren, Rotieren und Löschen der Accessories implementieren.

\begin{swiftcode}
    func addAccessoryView(accessoryView: AccessoryView) {
        self.accessoryOverlayView.addSubview(accessoryView)
        accessoryView.userInteractionEnabled = true
        // Bewegen
        let panGR = UIPanGestureRecognizer(target:self, action:"pan:")
        panGR.delegate = self
        accessoryView.addGestureRecognizer(panGR)
        // Skalieren
        let pinchGR = UIPinchGestureRecognizer(target:self, action:"pinch:")
        pinchGR.delegate = self
        accessoryView.addGestureRecognizer(pinchGR)
        // Drehen
        let rotateGR = UIRotationGestureRecognizer(target:self, action:"rotate:")
        rotateGR.delegate = self
        accessoryView.addGestureRecognizer(rotateGR)
        // Löschen
        let tapGR = UILongPressGestureRecognizer(target:self, action:"tap:")
        tapGR.delegate = self
        accessoryView.addGestureRecognizer(tapGR)
    }
    
    func gestureRecognizer(gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWithGestureRecognizer otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return true // Gesture Recognizer unterbrechen andernfalls die Erkennung einer Geste bei der Erkennung einer anderen
    }
    
    func pan(sender: UIPanGestureRecognizer) {
        if let accessoryView = sender.view {
            accessoryView.superview?.bringSubviewToFront(accessoryView)
            let translation = sender.translationInView(accessoryView.superview!)
            accessoryView.center = CGPoint(x: accessoryView.center.x + translation.x, y: accessoryView.center.y + translation.y)
            sender.setTranslation(CGPointZero, inView: accessoryView.superview!)
        }
    }
    func pinch(sender: UIPinchGestureRecognizer) {
        if let accessoryView = sender.view {
            accessoryView.superview?.bringSubviewToFront(accessoryView)
            accessoryView.transform = CGAffineTransformScale(accessoryView.transform, sender.scale, sender.scale);
            sender.scale = 1
        }
    }
    func rotate(sender: UIRotationGestureRecognizer) {
        if let accessoryView = sender.view {
            accessoryView.superview?.bringSubviewToFront(accessoryView)
            accessoryView.transform = CGAffineTransformRotate(accessoryView.transform, sender.rotation);
            sender.rotation = 0
        }
    }
    private var selectedAccessoryView: UIView?
    func tap(sender: UILongPressGestureRecognizer) {
        if sender.state != .Began {
            return
        }
        if let accessoryView = sender.view {
            self.becomeFirstResponder()
            let menuController = UIMenuController.sharedMenuController()
            menuController.menuItems = [ UIMenuItem(title: "Remove", action:"removeAccessoryButtonPressed:") ]
            menuController.setTargetRect(CGRect(x: accessoryView.center.x, y: accessoryView.center.y, width: 0, height: 0), inView: accessoryView.superview!)
            menuController.setMenuVisible(true, animated: true)
            self.selectedAccessoryView = accessoryView
        }
    }
    override func canBecomeFirstResponder() -> Bool {
        return true
    }
    func removeAccessoryButtonPressed(sender: AnyObject) {
        if let accessoryView = self.selectedAccessoryView {
            accessoryView.removeFromSuperview()
        }
    }
\end{swiftcode}

Hier sei angemerkt, dass wir aufgrund des Zusammenspiels verschiedener Gesture Recognizer jeweils Delta-Bewegungen verwenden und auf die View anwenden, indem der jeweilige Gesture Recognizer bei jedem Methodenaufruf zurückgesetzt wird.

Der \swiftinline{UILongPressGestureRecognizer} zeigt einen speziellen \swiftinline{UIMenuController} zur Darstellung eines \str{Entfernen} Buttons. Damit dieser korrekt angezeigt wird, muss die \swiftinline{canBecomeFirstResponder} Methode implementiert werden.

\item Die Integration eines \strong{Activity Sheets} zum Teilen von Inhalten ist denkbar einfach. \swiftinline{UIKit} stellt dafür den \swiftinline{UIActivityViewController} zur Verfügung, der eine Liste von Datenobjekten annimmt und abhängig vom Typ der Daten eine Auswahl von Kanälen zum Teilen anzeigt. Das Bild sollte in einer Computed Property stets neu generiert werden.

\begin{swiftcode}
    @IBAction func actionButtonPressed(sender: AnyObject) {
        let activityViewController = UIActivityViewController(activityItems: [ self.renderedPicture ], applicationActivities: nil)
        self.presentViewController(activityViewController, animated: true, completion: nil)
    }
    var renderedPicture: UIImage {
        UIGraphicsBeginImageContextWithOptions(self.view.frame.size, true, 0)
        self.view.drawViewHierarchyInRect(self.view.bounds, afterScreenUpdates: true)
        let renderedPicture = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return renderedPicture
    }
\end{swiftcode}

\item Um die Benutzeroberfläche vollständig wiederherstellen zu können, müssen wir sowohl das Foto als auch die hinzugefügten Accessories speichern. Als Methode der Datenspeicherung bietet sich in dieser App das \strong{State Preservation} System an, doch auch die \strong{User Defaults} Mechanik könnte stattdessen verwendet werden.

Zur Speicherung der Accessories müssen wir in der \swiftinline{AccessoryView: UIImageView} Klasse zunächst das \swiftinline{NSCoding} Protokoll implementieren. Dieses Protokoll bietet die Möglichkeit, Objekte als \swiftinline{NSData} zu serialisieren. \swiftinline{UIImageView} implementiert dieses Protokoll bereits, speichert aber das angezeigte Bild nicht. Daher müssen wir in der Subklasse lediglich die beiden Schlüsselmethoden überschreiben:

\begin{swiftcode}
// AccessoryView.swift
import UIKit

class AccessoryView: UIImageView {
    init(accessory: Accessory) {
        super.init(image: accessory.image)
    }
    override func encodeWithCoder(aCoder: NSCoder) {
        if let image = self.image {
            aCoder.encodeObject(UIImagePNGRepresentation(image), forKey: "image")
        }
        super.encodeWithCoder(aCoder)
    }
    required init(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        if let imageData = aDecoder.decodeObjectForKey("image") as? NSData {
            self.image = UIImage(data: imageData)
        }
    }
}
\end{swiftcode}

\item Nun müssen wir das State Preservation System lediglich noch aktivieren. Dazu müssen zwei Methoden im App Delegate implementiert werden:
\begin{swiftcode}
    func application(application: UIApplication, shouldSaveApplicationState coder: NSCoder) -> Bool {
        return true
    }
    func application(application: UIApplication, shouldRestoreApplicationState coder: NSCoder) -> Bool {
        return true
    }	
\end{swiftcode}

Außerdem muss jeder View Controller, der wiederhergestellt werden soll, sowohl alle View Controller in seiner View Controller Hierarchie, einen \swiftinline{restorationIdentifier} besitzen. Dieser kann im Storyboard im Identity Inspector zugewiesen werden. Der Navigation Controller und der Canvas View Controller benötigen also einen solchen.

Schließlich muss nur noch die Wiederherstellung des Canvas View Controllers konfiguriert werden. Dies geschieht in zwei Methoden, die wir überschreiben müssen:
\begin{swiftcode}
    // in CanvasViewController.swift
    override func encodeRestorableStateWithCoder(coder: NSCoder) {
        if let photo = photoImageView.image {
            let imageData = UIImagePNGRepresentation(photo)
            coder.encodeObject(imageData, forKey: "photo")
        }
        coder.encodeObject(NSKeyedArchiver.archivedDataWithRootObject(self.accessoryViews), forKey: "accessoryViews")
        super.encodeRestorableStateWithCoder(coder)
    }
    override func decodeRestorableStateWithCoder(coder: NSCoder) {
        if let photoData = coder.decodeObjectForKey("photo") as? NSData {
            photoImageView.image = UIImage(data: photoData)
        }
        if let accessoryViewsData = coder.decodeObjectForKey("accessoryViews") as? NSData {
            let accessoryViews = NSKeyedUnarchiver.unarchiveObjectWithData(accessoryViewsData) as! [AccessoryView]
            for accessoryView in accessoryViews {
                self.addAccessoryView(accessoryView)
            }
        }
        super.decodeRestorableStateWithCoder(coder)
    }	
\end{swiftcode}

Hier verwenden wir wieder die \swiftinline{addAccessoryView:} Methode um die Accessories der View Hierarchie hinzuzufügen und die Gesture Recognizer zu erzeugen.

\item Implementieren wir einen weiteren Toolbar Button, der die Benutzeroberfläche bei Betätigung \strong{zurücksetzt}, sollte zunächst eine Schaltfläche zur Bestätigung erscheinen. Dazu eignet sich wieder ein \swiftinline{UIAlertController} im \swiftinline{.ActionSheet} Stil.

\end{itemize}


\subsubsection{Der Seasonizer auf GitHub}

Auf GitHub findet ihr eine Beispielimplementierung des Seasonizers \linkref{https://github.com/iOS-Dev-Kurs/seasonizer}, die ihr als Referenz verwenden und auch weiterentwickeln könnt.

Haltet ihr eure Änderungen für so genial oder notwendig, dass sie in mein Original Repository übernommen werden sollten, könnt ihr mir über die GitHub Webseite eine \strong{Pull Request} schicken, die mich auffordert, einen Merge mit den Änderungen durchzuführen. In dieser Form kann ein Open Source Programmierprojekt weltweit von interessierten Entwicklern weiterentwickelt werden. Und dem Seasonizer sind damit keine Grenzen gesetzt.

\end{lecture}


\end{document}
